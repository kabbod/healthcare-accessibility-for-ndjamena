---
title: "R Notebook"
output:
  html_notebook: default
  pdf_document: default
Author: Kabbod Alkhalil
---

# Libraries


### Installing Packages
```{r}
install.packages(c("osmdata", "sf", "ggplot2", "dplyr", "ggmap", "tidyverse", "raster", "openrouteservice", "viridis", "plotly", "tmap", "terra", "readxl", "osrm", "mapview", "mapedit", "httr", "jsonlite", "openxlsx", "smoothr", "patchwork", "writexl", "ggspatial", "htmlwidgets", "leaflet", "scales", "httr2", "ggpmisc"));

```

### Loading Libraries
```{r}
library(osmdata);
library(sf);
library(ggplot2);
library(dplyr);
library(ggmap);
library(tidyverse);
library(raster);
library(openrouteservice);
library(viridis)
library(tmap)
library(plotly)
library(terra)
library(readxl)
library(osrm)
library(mapview)
library(mapedit)
library(jsonlite)
library(httr)
library(openxlsx)
library(smoothr)
library(patchwork)
library(writexl)
library(ggspatial)
library(htmlwidgets)
library(leaflet)
library(scales)
library(httr2)
library(ggpmisc)
```

# Reading the Inputs

### API Keys
```{r}
GoogleAPIKey <- ""
ors_api_key <- ""

register_google(key = GoogleAPIKey)

```
### Boundary of N'Djamena
The boundary box of N'Djamena was obtained from OpenStreetMap (OSM) data and expanded by 0.05°
```{r}
# Use N'Djamena's name to get its bbox
ndjamena_bbox <- getbb("N'Djamena, Chad")
#print(ndjamena_bbox)
ndjamena_bbox <- matrix(
  data = c(ndjamena_bbox[1, 1] - 0.05, ndjamena_bbox[1, 2] + 0.05, ndjamena_bbox[2, 1] - 0.05, ndjamena_bbox[2, 2] + 0.05),
  nrow = 2,
  ncol = 2,
  byrow = T,
  dimnames = list(c('x','y'), c('min', 'max'))
)
#print(ndjamena_bbox)
```

### Background Layer(s)
This section reads in the background layer(s) that will be used when generating maps of N'Djamena

```{r}

background_data <- get_map(ndjamena_bbox, maptype = "roadmap")

```

### Load N'Djamena Hospitals, Roads, Buildings, Administrative Boundaries...from OSM Data

```{r}
# Actual boundary of N'Djamena, this will allow us to plot the boundaries of the city and to also ensure that we only consider the data within the city when plotting
boundary_ndj <- boundary$osm_multipolygons %>% 
  filter (name == "N'Djaména انجمينا") 
boundary_ndj <- st_set_crs(boundary_ndj, 4326) # setting CRS (Coordinate Reference System) to 4326

# Get roads data
roads <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "highway") %>%
  osmdata_sf()

# Get buildings data
buildings <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "building") %>%
  osmdata_sf()

# Get hospitals data
hospitals <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "amenity", value = "hospital") %>%
  osmdata_sf()

# Get the administrative boundary of N'Djamena
boundary <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "boundary", value = "administrative") %>%
  add_osm_feature(key = "admin_level", value = "4") %>%
  osmdata_sf()

# Get the neighborhoods of N'Djamena
neighborhoods <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "boundary", value = "administrative") %>%
  add_osm_feature(key = "admin_level", value = "10") %>%
  osmdata_sf()

# Get the arrondissements of N'Djamena
arrondissements <- opq(bbox = ndjamena_bbox) %>%
  add_osm_feature(key = "boundary", value = "administrative") %>%
  add_osm_feature(key = "admin_level", value = "9") %>%
  osmdata_sf()


# Plotting neighborhoods in N'Djamena
ggplot() +
  geom_sf(data = neighborhoods$osm_multipolygons, aes(color = "Neighborhoods"), size = 0.1, alpha = 1) +
  geom_sf(data = boundary_ndj, aes(color = "City Boundary"), fill = NA, size = 1.5, inherit.aes = FALSE) + # City Boundary
  geom_sf_text(
    data = neighborhoods$osm_multipolygons, 
    aes(label = substr(`name:fr`, 1, 4)), # Replace 'name' with the column containing the arrondissement names
    size = 3, # Adjust text size
    color = "blue" # Text color
  ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("City Boundary" = "red", "Neighborhoods" = "black") # Colors for the legend
  ) +
  theme_void() +
  ggtitle("Map of N'Djamena with the Different Neighborhoods")


# Plotting arrondissements in N'Djamena
ggplot() +
  geom_sf(data = arrondissements$osm_multipolygons, aes(color = "Arrondissements"), fill = "cyan",size = 0.1, alpha = 1) + # Arrondissements
  geom_sf(data = boundary_ndj, aes(color = "City Boundary"), fill = NA, size = 1, inherit.aes = FALSE) + # City Boundary
  geom_sf_text(
    data = arrondissements$osm_multipolygons, 
    aes(label = substr(`name:fr`, 1, 4)), # Replace 'name' with the column containing the arrondissement names
    size = 3, # Adjust text size
    color = "blue" # Text color
  ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("City Boundary" = "red", "Arrondissements" = "black") # Colors for the legend
  ) +
  theme_void() +
  ggtitle("Map of N'Djamena with the Different Arrondissements")


# Plotting City Boundary, Arrondissements and Neighborhoods
ggplot() +
  # Neighborhoods as dashed lines
  geom_sf(data = neighborhoods$osm_multipolygons, 
          aes(color = "Neighborhoods"), 
          fill = NA, 
          size = 0.5, 
          linetype = "dashed") +
  
  # Arrondissements as solid black contour with gray fill
  geom_sf(data = arrondissements$osm_multipolygons, 
          aes(fill = "Arrondissements"), 
          color = "black", 
          size = 0.5, 
          alpha = 0.3) +
  
  # City Boundary as a red line
  geom_sf(data = boundary_ndj, 
          aes(color = "City Boundary"), 
          fill = NA, 
          size = 1.5) + 
  
  # Custom color and fill scale
  scale_color_manual(
    name = "",
    values = c("City Boundary" = "red", "Neighborhoods" = "black") # Colors for lines
  ) +
  scale_fill_manual(
    name = "Legend",
    values = c("Arrondissements" = "grey70") # Fill color for Arrondissements
  ) +
  
  # Theme and title
  theme_void() +
  ggtitle("Map of N'Djamena with Arrondissements & Neighborhoods")


```

### Enhancing the Data/Data Clean Up
This section will allow clean up the data and for instance add hospitals that weren't part of the initial data set
```{r}
# Extract hospital data points
hospital_points <- hospitals$osm_points

# Data for missing hospitals
missing_hospitals <- data.frame(
  name = c("Le Bon Samaritain Hospital", "Hopital de l'Union"), # Hospital names
  lon = c(15.08556, 15.08488),           # Longitudes
  lat = c(12.08617, 12.09519)            # Latitudes
)

# Convert to sf object
missing_hospitals_sf <- st_as_sf(
  missing_hospitals,
  coords = c("lon", "lat"),  # Columns for coordinates
  crs = 4326                # CRS (use the same as your existing data)
)

# Add missing columns to `missing_hospitals_sf`
for (col in setdiff(names(hospital_points), names(missing_hospitals_sf))) {
  missing_hospitals_sf[[col]] <- NA
}


# Reorder columns of `missing_hospitals_sf` to match `hospital_points'
missing_hospitals_sf <- missing_hospitals_sf[, names(hospital_points)]

# Ensure hospital_polygons CRS matches
hospital_points <- st_transform(hospital_points, crs = st_crs(missing_hospitals_sf))

# Combine missing hospitals with existing hospitals
hospital_points <- rbind(
  hospital_points,         # Existing hospital data
  missing_hospitals_sf       # Newly added hospitals
)

# Check and make geometries valid
hospital_points <- st_make_valid(hospital_points)

# Filter out invalid geometries
hospital_points <- hospital_points[!is.na(st_is_valid(hospital_points)), ]


```

#### Limit the Data to Intra-N'Djamena
This section will generate the actual boundary of N'Djamena and allow us to filter the data above to only what is within the boundaries of the city. We will also plot the data above...
```{r}
# Actual boundary of N'Djamena, this will allow us to plot the boundaries of the city and to also ensure that we only consider the data within the city when plotting
boundary_ndj <- boundary$osm_multipolygons %>% 
  filter (name == "N'Djaména انجمينا") 
boundary_ndj <- st_set_crs(boundary_ndj, 4326) # setting CRS (Coordinate Reference System) to 4326

# Creating function to determine what is in a given boundary
filter_points_within_boundary <- function(boundary, points) {
  # Check if points are within the boundary
  index_contained <- st_contains(boundary, points) %>% 
    unlist()
  
  # Subset the points based on the indices
  points_restricted <- points %>% slice(index_contained)
  
  return(points_restricted)
}

# Filtering the hospitals data to only show the ones that are within the city boundary
hospitals_points_restricted <- filter_points_within_boundary(boundary_ndj, hospital_points)

ggplot() +
  geom_sf(data = roads$osm_lines, color = "blue", size = 0.1, alpha = 0.7) +
  geom_sf(data = buildings$osm_polygons, fill = "grey80", color = "black", size = 0.1, alpha = 0.6) +
  geom_sf(data = hospital_points, color = "red", size = 1, alpha =1)+
  geom_sf(data = boundary_ndj, fill = NA, color = "red", size = 6, inherit.aes = FALSE) + # City Boundary
  theme_void() +
  ggtitle("Map of N'Djamena with roads, hospitals, and buildings")
  
  
# Plot hospitals on a map
ggmap(background_data) +
  # Base layer for boundary (optional)
  geom_sf(data = boundary_ndj, fill = NA, color = "red", size = 6, inherit.aes = FALSE) +
  # Add hospital locations
  geom_sf(data = hospital_points, aes(color = "Hospital"), size = 1, alpha = 0.7, shape = 21, fill = "purple", inherit.aes = FALSE) +
  ggtitle("Hospitals in N'Djamena per OSM Data") +
  theme_minimal()

# Plot hospitals on a map WITH HOSPITALS RESTRICTED
ggmap(background_data) +
  # Base layer for boundary (optional)
  geom_sf(data = boundary_ndj, fill = NA, color = "red", size = 6, inherit.aes = FALSE) +
  # Add hospital locations
  geom_sf(data = hospitals_points_restricted, aes(color = "Hospital"), size = 1, alpha = 0.7, shape = 21, fill = "purple", inherit.aes = FALSE) +
  ggtitle("Hospitals in N'Djamena within the City Boundary") +
  theme_minimal()  
```

### Adding the Square Grids for Evaluation

```{r}

# Use N'Djamena's name to get its bbox
ndjamena_bbox <- getbb("N'Djamena, Chad")
#print(ndjamena_bbox)
ndjamena_bbox <- matrix(
  data = c(ndjamena_bbox[1, 1]-0.01, ndjamena_bbox[1, 2] + 0.07, ndjamena_bbox[2, 1] - 0.1, ndjamena_bbox[2, 2] + 0.05),
  #data = c(ndjamena_bbox[1, 1] - 0.05, ndjamena_bbox[1, 2] + 0.05, ndjamena_bbox[2, 1] - 0.1, ndjamena_bbox[2, 2] + 0.05),
  nrow = 2,
  ncol = 2,
  byrow = T,
  dimnames = list(c('x','y'), c('min', 'max'))
)


# Convert bbox to an sf polygon
ndjamena_polygon <- st_as_sfc(st_bbox(
  c(xmin = ndjamena_bbox[1, "min"],
    ymin = ndjamena_bbox[2, "min"],
    xmax = ndjamena_bbox[1, "max"],
    ymax = ndjamena_bbox[2, "max"]),
  crs = 4326  # Assuming WGS84 CRS
)) 

# Convert sfc object to an sf object
ndjamena_sf <- st_sf(geometry = ndjamena_polygon)

ggplot() +
  geom_sf(data = ndjamena_polygon, fill = NA, color = "black", size = 0.5, inherit.aes = F) +
  geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 1.2, inherit.aes = F) +
  ggtitle("1km² Grid over N'Djamena") +
  theme_minimal()
plot(ndjamena_polygon)


# Step 1: Define the extent of the city (use city boundary or bounding box)
# Example: Using city boundary to define extent
city_boundary <- st_transform(ndjamena_sf, crs = 4326)  # Ensure CRS is in lat/lon
city_bbox <- st_bbox(city_boundary)  # Get the bounding box
  
# Step 2: Create a raster grid with 1km resolution
# Define the resolution in degrees (approx. 1km ~ 0.0089 degrees at the equator)
r <- raster(
  xmn = city_bbox["xmin"], xmx = city_bbox["xmax"],
  ymn = city_bbox["ymin"], ymx = city_bbox["ymax"],
  resolution = 0.0089  # Approx. 1km in degrees
  #resolution = 0.0156  # Approx. 3km in degrees
  #resolution = 0.0201  # Approx. 5km in degrees
  #resolution = 0.0238  # Approx. 7km in degrees
)

# Assign a unique ID to each grid cell
values(r) <- 1:ncell(r)

# Step 3: Convert the raster to polygons (optional, for use with ggplot or sf)
grid_polygons <- rasterToPolygons(r, dissolve = TRUE)
grid_sf <- st_as_sf(grid_polygons)
grid_sf <- st_set_crs(grid_sf, 4326)

# Plot all the grids over the city of N'Djamena while showing the boundary of the city
ggplot() +
  geom_sf(data = grid_sf, fill = NA, color = "black", size = 0.5, inherit.aes = F) +
  geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 1.2, inherit.aes = F) +
  ggtitle("1km² Grid Over the Entire Boundary Box") +
  theme_minimal()

# Calculating the Centroids of all those grids
grid_centroids <- st_centroid(grid_sf)

# Plotting ALL the grid centroids over the city boundary
ggplot() +
  geom_sf(data = grid_centroids, size = 3, fill = "blue", alpha = 0.5, inherit.aes = FALSE) +
  geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 1.2, inherit.aes = F) +
  ggtitle("1km² Grid over N'Djamena with ALl the Grid Centroids") +
  theme_minimal()

# How to restrict to only the grid centroids that are within the city boundary 
grid_sf_restricted <- filter_points_within_boundary(ndjamena_boundary, grid_centroids)


# Step 4: Plot the grid over the city boundary
ggplot() +
  geom_sf(data = grid_sf_restricted, fill = NA, color = "black", size = 0.5, inherit.aes = F) +
  geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 1.2, inherit.aes = F) +
  ggtitle("1km² Grid over N'Djamena") +
  theme_minimal()
  
  
# represent the different grid points on the N'Djamena map
ggmap(background_data) +
  # Base layer for boundary (optional)
  geom_sf(data = boundary_ndj, fill = NA, color = "black", size = 6, inherit.aes = FALSE) +
  # Add centroids
  geom_sf(data = grid_sf_restricted, size = 3, fill = "red", alpha = 0.5, inherit.aes = FALSE) +
  ggtitle("Centroids of 1 km2") +
  theme_minimal()


```

### Loading Population Data
#### Gridded Population of the World (GPW)
```{r}
# Specify the file path
worldpop_file <- "/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Data/Population/GPW/gpw-v4-population-density-rev11_2020_30_sec_tif/gpw_v4_population_density_rev11_2020_30_sec.tif"

# Load the raster data
worldpop_raster <- rast(worldpop_file)

# Plot the data
plot(worldpop_raster, main = "World Population Data - Source - Gridded Population of the World (GPW)")


# Ensuring WorldPop data and OSM data are using the same CRS
boundary_ndj <- st_transform(boundary_ndj, crs = crs(worldpop_raster))


# Crop the WorldPop raster using the bounding box extent - we crop first, before masking, because it is a computationally expensive task. Masking will then allow us to further restrict the data to only show what is within the boundaries of the city
cropped_raster <- crop(worldpop_raster, ndjamena_sf)


plot(cropped_raster, main = "Population of N'Djamena within Bounding Box - GPW")

# Masking the cropped raster - to restric the data to the boundaries of N'Djamena
masked_raster <- mask(cropped_raster, boundary_ndj)


# Convert the raster to a data frame for ggplot2
raster_df <- as.data.frame(cropped_raster, xy = TRUE, na.rm = TRUE)


#raster_df$tcd_ppp_2020_UNadj_constrained

# Plot the population distribution
ggplot(raster_df, aes(x = x, y = y, fill = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Population Distribution in N'Djamena - GPW", fill = "Population")

# Log Scale
ggplot(raster_df, aes(x = x, y = y, fill = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_tile() +  # Use tiles to represent raster data
  scale_fill_viridis_c(option = "viridis", trans = "log", na.value = "white") +  # Use viridis color palette with a log scale
  theme_minimal() +
  labs(
    title = "Population Distribution in N'Djamena - GPW - Log Scale",
    fill = "Population"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_blank()
  )


# Histogram  
ggplot(raster_df, aes(x = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "blue", alpha = 0.5) +
  geom_density(color = "red", size = 1) +
  theme_minimal() +
  labs(
    title = "Population Distribution in N'Djamena",
    x = "Population per Pixel",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )
# Density Curve
ggplot(raster_df, aes(x = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_density(fill = "blue", alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "Density Distribution of Population in N'Djamena",
    x = "Population per Pixel",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )

# Density Curve with Log Transform
ggplot(raster_df, aes(x = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_density(fill = "blue", alpha = 0.5) +
  scale_x_log10() +
  theme_minimal() +
  labs(
    title = "Log-Transformed Density Distribution of Population in N'Djamena",
    x = "Log(Population per Pixel)",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )

# Removing population under 1000 per pixel - because there appears to be a data with very low population count
raster_df_filtered <- raster_df %>% 
  filter(gpw_v4_population_density_rev11_2020_30_sec > 1000)


# Plot the population distribution - with the filtered data
ggplot(raster_df_filtered, aes(x = x, y = y, fill = gpw_v4_population_density_rev11_2020_30_sec)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Filtered Population Distribution in N'Djamena - GPW", fill = "Population")

```

#### World Pop Data
```{r}
# Specify the file path
worldpop_file <- '/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Data/Population/WorldPop/tcd_ppp_2020_UNadj_constrained.tif'

# Load the raster data
worldpop_raster <- raster(worldpop_file)

# Plot the data
# plot(worldpop_raster, main = "World Population Data - Source - WorldPop")


# Ensuring WorldPop data and OSM data are using the same CRS
boundary_ndj <- st_transform(boundary_ndj, crs = crs(worldpop_raster))


# Crop the WorldPop raster using the bounding box extent - we crop first, before masking, because it is a computationally expensive task. Masking will then allow us to further restrict the data to only show what is within the boundaries of the city
cropped_raster <- crop(worldpop_raster, ndjamena_sf)


plot(cropped_raster, main = "Population of N'Djamena within Bounding Box - WorlPop")

# Masking the cropped raster - to restric the data to the boundaries of N'Djamena
masked_raster <- mask(cropped_raster, boundary_ndj)


# Convert the raster to a data frame for ggplot2
raster_df <- as.data.frame(masked_raster, xy = TRUE, na.rm = TRUE)


#raster_df$tcd_ppp_2020_UNadj_constrained

# Plot the population distribution
ggplot(raster_df, aes(x = x, y = y, fill = tcd_ppp_2020_UNadj_constrained)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Population Distribution in N'Djamena - WorldPop", fill = "Population")



# Plot with population density and city boundary
ggplot() +
  # Population density as a raster or tile
  geom_tile(data = raster_df, aes(x = x, y = y, fill = tcd_ppp_2020_UNadj_constrained)) +
  scale_fill_viridis_c(name = "Population Density") +  # Color gradient for density
  
  # City boundary as a red line
  geom_sf(data = boundary_ndj, aes(color = "City Boundary"), fill = NA, size = 1, inherit.aes = FALSE) +
  scale_color_manual(values = c("City Boundary" = "red"), name = "Legend") +
  
  # Add labels and themes
  labs(title = "Population Density and City Boundary in N'Djamena",
       x = "Longitude",
       y = "Latitude") +
  theme_minimal() +
  theme(legend.position = "bottom")


# Log Scale
ggplot(raster_df, aes(x = x, y = y, fill = tcd_ppp_2020_UNadj_constrained)) +
  geom_tile() +  # Use tiles to represent raster data
  scale_fill_viridis_c(option = "viridis", trans = "log", na.value = "white") +  # Use viridis color palette with a log scale
  theme_minimal() +
  labs(
    title = "Population Distribution in N'Djamena - WorldPop - Log Scale",
    fill = "Population"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_blank()
  )


# Histogram  
ggplot(raster_df, aes(x = tcd_ppp_2020_UNadj_constrained)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "blue", alpha = 0.5) +
  geom_density(color = "red", size = 1) +
  theme_minimal() +
  labs(
    title = "Population Distribution in N'Djamena",
    x = "Population per Pixel",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )
# Density Curve
ggplot(raster_df, aes(x = tcd_ppp_2020_UNadj_constrained)) +
  geom_density(fill = "blue", alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "Density Distribution of Population in N'Djamena",
    x = "Population per Pixel",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )

# Density Curve with Log Transform
ggplot(raster_df, aes(x = tcd_ppp_2020_UNadj_constrained)) +
  geom_density(fill = "blue", alpha = 0.5) +
  scale_x_log10() +
  theme_minimal() +
  labs(
    title = "Log-Transformed Density Distribution of Population in N'Djamena",
    x = "Log(Population per Pixel)",
    y = "Density"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )

# # Removing population under 1000 per pixel - because there appears to be a data with very low population count
# raster_df_filtered <- raster_df %>% 
#   filter(gpw_v4_population_density_rev11_2020_30_sec > 1000)
# 
# 
# # Plot the population distribution - with the filtered data
# ggplot(raster_df_filtered, aes(x = x, y = y, fill = gpw_v4_population_density_rev11_2020_30_sec)) +
#   geom_tile() +
#   scale_fill_viridis_c() +
#   theme_minimal() +
#   labs(title = "Filtered Population Distribution in N'Djamena - GPW", fill = "Population")

```

# Data Analysis

### Average Times

#### Using Open Route Service API
This section calculates the average time (min) it takes to travel from each origin grid point to all the hospitals in N'Djamena. As it stands today, I'm only sampling a few points (14) from the 350 origin grid points/centroids to the hospitals to meet the max (free) query number of 3,500 routes.
```{r}
# calculate points from each grid centroid to hospital points **** using OpenRouteService
# Sample 14 origins from grid_centroids
set.seed(123)  # For reproducibility
sampled_origins <- grid_sf_restricted %>% sample_n(48)

# Sample destinations/hospitals
set.seed(123)  # For reproducibility
sampled_destinations <- hospitals_points_restricted %>% sample_n(10)

# Prepare origins and destinations as lists of [lon, lat]
origin_coords <- st_coordinates(sampled_origins) %>% # will need to replace sampled_origins with grid_centroids
  as.data.frame() %>%
  rename(lon = X, lat = Y)

dest_coords <- st_coordinates(sampled_destinations) %>% # will need to replace sampled_origins with hospitals_points_restricted
  as.data.frame() %>%
  rename(lon = X, lat = Y)

# Format origins and destinations as lists of [lon, lat]
origins <- split(origin_coords, seq(nrow(origin_coords))) %>%
  lapply(function(row) c(row$lon, row$lat))

destinations <- split(dest_coords, seq(nrow(dest_coords))) %>%
  lapply(function(row) c(row$lon, row$lat))


# Combine all origins and destinations into one request
locations <- c(origins, destinations)

# API request to OpenRouteService for travel times
response <- ors_matrix(
  locations = locations,  # Combined origins and destinations
  metrics = c("duration"),  # Request travel times (duration in seconds)
  api_key = ors_api_key,
  profile = "driving-car"  # Use "driving-car", "cycling-regular", "foot-walking", etc.
)

# Extract durations (travel times in seconds)
n_origins <- length(origins)
n_destinations <- length(destinations)
durations <- response$durations[1:n_origins, (n_origins + 1):(n_origins + n_destinations)]

# Calculate average travel time for each origin
avg_times <- apply(durations, 1, function(row) mean(row, na.rm = TRUE))

# Store results in the origins dataframe (in minutes)
origin_coords$average_time <- avg_times/60

# Print the results or further analyze the output
print(origin_coords)

# # Plotting average times
# ggmap_plot <- ggmap(background_data) +
#   geom_point(data = origin_coords, aes(x = lon, y = lat, color = average_time), size = 6.4, shape = 15, alpha = 0.5) + #shape = 15 is a filled square
#   scale_color_viridis(option = "C") +  # Apply a color scale (can use "A", "B", "C", etc.)
#   geom_sf(data = boundary_ndj, aes(color = "City Boundary"), fill = NA, color = "red", size = 6, inherit.aes = FALSE) +
#   labs(title = "Average Travel Time to Hospitals for 7km2 Centroids Using ORS", color = "Avg. Time (min)") +
#   theme_minimal() +
#   theme(legend.position = "right")
# ggmap_plot


# Plotting Average Times
ggplot()+
  # Base raster layer for average travel time
  geom_tile(data = origin_coords, aes(x = lon, y = lat, fill = average_time)) +
  scale_fill_viridis_c(name = "Travel Time (min)") +  # Color gradient for travel time
  
  # Overlay city boundary
  geom_sf(data = boundary_ndj, color = "red", size = 1, fill = NA, inherit.aes = FALSE) +
  
  # Labels and themes
  labs(
    title = "Average Travel Time in N'Djamena - 7km2 Grids",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")


# Same plot with OSM background layer of N'Djamena
ggmap_plot <- ggmap(background_data) +
  # Base raster layer for average travel time
  geom_tile(data = origin_coords, aes(x = lon, y = lat, fill = average_time)) +
  scale_fill_viridis_c(name = "Travel Time (min)") +  # Color gradient for travel time
  # Overlay city boundary
  geom_sf(data = boundary_ndj, aes(color = "City Boundary"), fill = NA, size = 1, inherit.aes = FALSE) +
  scale_color_manual(values = c("City Boundary" = "red"), name = "Legend") +
  # Labels and themes
  labs(
    title = "Average Travel Time in N'Djamena - 7km2 Grids",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
ggmap_plot



# Convert to interactive plot
# interactive_map <- ggplotly(ggmap_plot)
# interactive_map


```

#### Using Google Maps API
Learn more about it here - https://developers.google.com/maps/documentation/distance-matrix?hl=en

```{r}

```

# Setting up Working Directory

```{r setup, include=FALSE}

knitr::opts_knit$set(root.dir = "/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Graphs")

setwd("/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Graphs")
getwd()
```

# Functions

```{r}

#_____________________ EXPORT TO WORD ____________________________________________________
# Function to export any dataframe to Word
export_to_word <- function(df, file_name = "exported_table.docx") {
  # Convert dataframe to flextable
  table_word <- flextable(df)
  
  # Export to Word document
  doc <- read_docx() %>%
    body_add_flextable(table_word) %>%
    print(target = file_name)
  
  message(paste("Table successfully saved as:", file_name))
}




#_______________  SAVE PLOT AS A PNG ___________________________________________________

export_ggplot_as_png <- function(plot, filename, width = 4000, height = 3000, res = 300) {
  # Save the plot to a PNG file
  png(filename = filename, width = width, height = height, res = res)
  print(plot)  # Print the plot inside the PNG device
  dev.off()  # Close the device
  message(paste("Plot successfully saved as:", filename))
}


```
# Data from Tchindibe

```{r}

# **************************** READING DATA ****************

setwd("/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Graphs")
getwd()

# NEIGHBORHOODS
neighborhoods <- st_read("/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Quartiers/QTIERS.shp")

# # Determining the centroids of each neighborhood
# # Check for geometry issues
# neighborhoods <- st_make_valid(neighborhoods)
# # Reproject to WGS 84 (EPSG 4326)
# neighborhoods <- st_transform(neighborhoods, crs = 4326)
centroids <- st_centroid(neighborhoods)
# # Determine the contour of the city
# contour_neighborhoods <- st_make_valid(contour_neighborhoods)
# contour_neighborhoods <- st_boundary(st_union(neighborhoods))

# Manually Determining Contour - MANUAL CONTOUR
# mapview(neighborhoods)
# # Interactive Editing - Hit Done button when done (use Polygon drawing)
# manual_contour_neighborhoods <- editMap(mapview(neighborhoods))
# # Visualize the Contour
# mapview(manual_contour_neighborhoods$drawn$geometry)
# # Now export as shapefile
# st_write(manual_contour_neighborhoods$drawn$geometry, '/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/NDjamena Contour from Neighborhoods/manual_contour_neighborhoods.shp')
# Read Contour
manual_contour_neighborhoods <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/NDjamena Contour from Neighborhoods/manual_contour_neighborhoods.shp')
# Change the CRS of the shapefile to the same as 'neighborhoods'
manual_contour_neighborhoods <- st_transform(manual_contour_neighborhoods, crs = 4326)
ndjamena_boundary <- manual_contour_neighborhoods
# Check the CRS
st_crs(manual_contour_neighborhoods)


# ZONE DE RESPONSABILITE
zonederesponsabilite <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite/zone_Responsabilité_.shp')
zonederesponsabilite <- st_transform(zonederesponsabilite, crs = 4326) # changing the reference



# DISTRICTS
district_9e <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite District 9e/zone_Responsabilité_District_9e.shp')
district_centre <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite District Centre/zone_Responsabilité_District_centre.shp')
district_est <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite District Est/zone_Responsabilité_District Est.shp')
district_nord <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite District Nord/zone_responsabilité_Distrcit_nord.shp')
district_sud <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Zone de Responsabilite District Sud/zone_Responsabilité _District_sud.shp')

district_9e <- st_transform(district_9e, crs = 4326) # changing the reference - Coordinate Reference System
district_centre <- st_transform(district_centre, crs = 4326) # changing the reference
district_est <- st_transform(district_est, crs = 4326) # changing the reference
district_nord <- st_transform(district_nord, crs = 4326) # changing the reference
district_sud <- st_transform(district_sud, crs = 4326) # changing the reference

# Combining all 5 districts
district_est <- district_est %>% select(-Pop_ZR) # removing population column name before combining
districts <- rbind(district_9e, district_centre, district_est, district_nord, district_sud)


# LIMIT DE DISTRICT
limitededistrict <- st_read('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Shapefile/Limite de Districts/Limite des Districts de ndjamena.shp')
limitededistrict <- st_transform(limitededistrict, crs = 4326) # changing the reference

#_______________ FIXING NEIGHBORHOOD DATA ___________________
# Neighborhood #33 (Atrone) had some issues when trying to join the travel time data with each neighborhood by finding which centroids fell in each neighborhood. In order to fix that issue, the data from the neighborhood was fixed below

# Check which geometries are invalid
invalid_geoms <- st_is_valid(neighborhoods)
# Print invalid geometries
which(!invalid_geoms)

# Extract the invalid geometry
invalid_geom <- neighborhoods[33, ]
# Plot the invalid geometry
plot(st_geometry(invalid_geom), col = "red", main = "Invalid Neighborhood Polygon")

# Fix only the invalid geometry
neighborhoods[33, ] <- st_make_valid(neighborhoods[33, ])
#Check if it's fixed
st_is_valid(neighborhoods[33, ])  # Should return TRUE



# ********************** PLOTTING ***************************
#contour_neighborhoods <- st_sf(geometry = contour_neighborhoods)

# # Contour of the City of N'Djamena
# ggplot()+
#   geom_sf(data = contour_neighborhoods, fill=NA, color = "red", size = 6)+
#   ggtitle("Contour of the City of N'Djamena")+
#   theme_void()

# Plotting Centroid Data
# ggmap(background_data) +
#   # Base layer for boundary (optional)
#   geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 6, inherit.aes = FALSE) +
#   # Centroids Data
#   geom_sf(data = centroids, size = 3, fill = "red", alpha = 0.5, inherit.aes = FALSE) +
#   ggtitle("Centroids") +
#   theme_void()

# Plotting NEIGHBORHOODS and NAMES in N'Djamena
p <- ggplot() +
  geom_sf(data = neighborhoods$geometry, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, size = 1.5, inherit.aes = FALSE) + # City Boundary
  geom_sf_text(
    data = neighborhoods,
    aes(label = NOM),
    #aes(label = substr(`NOM`, 1, 4)), # Replace 'name' with the column containing the arrondissement names
    size = 2, # Adjust text size
    color = "blue" # Text color
  ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black"), # "City Boundary" = "purple"), # Colors for the legend
  ) +
  ggtitle("Neighborhoods of N'Djamena")+
  theme_void() +
     theme(
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm"))  # Increase legend key size

export_ggplot_as_png(p, "Neighborhoods of N'Djamena.png")





# Plotting NEIGHBORHOODS and NAMES and GOOGLE MAPS in N'Djamena
ggmap(background_data) +
  geom_sf(data = neighborhoods$geometry, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5, inherit.aes = FALSE) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), size = 1.5, inherit.aes = FALSE) + # City Boundary
  # geom_sf(data = boundary_ndj, fill = NA, color = "purple", size = 6, inherit.aes = FALSE) +
  # geom_sf_text(
  #   data = neighborhoods,
  #   aes(label = NOM),
    #aes(label = substr(`NOM`, 1, 4)), # Replace 'name' with the column containing the arrondissement names
  #   size = 2, # Adjust text size
  #   color = "blue" # Text color
  # ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black", "City Boundary" = "red"), # "City Boundary" = "purple"), # Colors for the legend
  ) +
  theme_void() +
  ggtitle("Neighborhoods of N'Djamena")


# Plotting NEIGHBORHOODS and their CENTROIDS in N'Djamena
# ggplot() +
#   geom_sf(data = neighborhoods$geometry, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5, inherit.aes = FALSE) +
#   geom_sf(data = centroids, aes(color = "Centroids"), size = 1, alpha = 0.7, inherit.aes = FALSE)+
#   #geom_sf(data = contour, aes(color = "City Boundary"), fill = NA, size = 1.5, inherit.aes = FALSE) + # City Boundary
#   # geom_sf_text(
#   #   data = neighborhoods,
#   #   aes(label = NOM),
#   #   #aes(label = substr(`NOM`, 1, 4)), # Replace 'name' with the column containing the arrondissement names
#   #   size = 2, # Adjust text size
#   #   color = "blue" # Text color
#   # ) +
#   scale_color_manual(
#     name = "Legend", # Legend title
#     values = c("Neighborhoods" = "black", "Centroids" = "red"), # "City Boundary" = "purple"), # Colors for the legend
#     limits = c("Neighborhoods", "Centroids") #, "City Boundary"),  # Custom order
#   ) +
#   theme_void() +
#   ggtitle("Neighborhoods of N'Djamena and their Centroids")


# Plotting NEIGHBORHOODS and HOSPITALS in N'Djamena
g <- ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), size = 0.1, fill = "NA", alpha = 0.5) +
  geom_sf(data = hospitals_from_moh_sf, aes(color = "Hospitals"), size = 5, alpha = 0.7, inherit.aes = FALSE) + # adding hospitals
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black", "Hospitals" = "red"), # "City Boundary" = "purple"), # Colors for the legend
    limits = c("Neighborhoods", "Hospitals"),  # Custom order
  ) +
  ggtitle("Neighborhoods and Hospitals in N'Djamena")+
    theme_void() +
     theme(
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm"))  # Increase legend key size
  
  
export_ggplot_as_png(g, "Neighborhoods and Hospitals in N'Djamena.png")



# Plotting ZONE DE RESPONSABILITE in N'Djamena
ggplot() +
  geom_sf(data = zonederesponsabilite$geometry , aes(color = "Zone de Responsabilite"), size = 0.1, alpha = 0.5) +
  geom_sf_text(
    data = zonederesponsabilite,
    aes(label = substring(Nom,4)),
    size = 2, # Adjust text size
    color = "blue" # Text color
  ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Zone de Responsabilite" = "black"), # Colors for the legend
    #limits = c("Neighborhoods", "Centroids"),  # Custom order
  ) +
  theme_void() +
  ggtitle("Zone de Responsabilite in N'Djamena")



# Plotting ZONE DE RESPONSABILITE with NEIGHBORHOODS
ggplot() +
  geom_sf(data = zonederesponsabilite$geometry , aes(color = "Zone de Responsabilite"), size = 0.1, alpha = 0.5, fill="cyan") +
  geom_sf(data = neighborhoods$geometry , aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5, linetype = "dashed") +
  geom_sf_text(
    data = zonederesponsabilite,
    aes(label = substring(Nom,4)),
    size = 2, # Adjust text size
    color = "blue" # Text color
  ) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Zone de Responsabilite" = "black", "Neighborhoods" = "black"), # Colors for the legend
    limits = c("Zone de Responsabilite", "Neighborhoods"),  # Custom order
  ) +
  theme_void() +
  ggtitle("Zone de Responsabilite in N'Djamena")


# Plotting DISTRICTS in N'Djamena
ggplot()+
  #geom_sf(data = districts, aes(color = "Districts"), fill= "pink", size = 6, alpha=0.5)+
  geom_sf(data = district_9e, aes(color = "District 9e"), fill= "red", size = 6, alpha=0.5)+
  geom_sf(data = district_centre, aes(color = "District Centre"), fill= "blue", size = 6, alpha=0.5)+
  geom_sf(data = district_est, aes(color = "District Est"), fill= "orange", size = 6, alpha=0.5)+
  geom_sf(data = district_nord, aes(color = "District Nord"), fill= "purple", size = 6, alpha=0.5)+
  geom_sf(data = district_sud, aes(color = "District Sud"), fill= "green", size = 6, alpha=0.5)+
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("District 9e" = "black", "District Centre" = "black", "District Est" = "black", "District Nord" = "black", "District Sud" = "black"), # Colors for the legend
  ) +
  ggtitle("The Five Districts of N'Djamena")+
  theme_void()

# Plotting DISTRICTS with Hospitals in N'Djamena
ggplot()+
  #geom_sf(data = districts, aes(color = "Districts"), fill= "pink", size = 6, alpha=0.5)+
  geom_sf(data = district_9e, aes(color = "District 9e"), fill= "red", size = 6, alpha=0.5)+
  geom_sf(data = district_centre, aes(color = "District Centre"), fill= "blue", size = 6, alpha=0.5)+
  geom_sf(data = district_est, aes(color = "District Est"), fill= "orange", size = 6, alpha=0.5)+
  geom_sf(data = district_nord, aes(color = "District Nord"), fill= "purple", size = 6, alpha=0.5)+
  geom_sf(data = district_sud, aes(color = "District Sud"), fill= "green", size = 6, alpha=0.5)+
  geom_sf(data = hospitals_from_moh_sf, aes(color = "Hospitals"), size = 1, inherit.aes = FALSE) + # adding hospitals
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("District 9e" = "black", "District Centre" = "black", "District Est" = "black", "District Nord" = "black", "District Sud" = "black", "Hospitals" = "black"), # Colors for the legend
  ) +
  ggtitle("The Five Districts of N'Djamena and Hospitals")+
  theme_void()

# Districts and Neighborhoods
ggplot()+
  geom_sf(data = districts, aes(color = "Districts"), fill= "pink", size = 6, alpha=0.5)+
  geom_sf(data = limitededistrict, aes(color = "Limite de District"), fill = "orange", size = 6, alpha = 0.1)+
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("Districts" = "black", "Limite de District" = "red"), # Colors for the legend
  ) +
  ggtitle("Districts and Limite de District in N'Djamena")+
  theme_void()

# Districts and Neighborhoods
ggplot()+
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill= "pink", size = 6, alpha=0.5)+
  geom_sf(data = limitededistrict, aes(color = "Limite de District"), fill = "orange", size = 6, alpha = 0.1)+
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black", "Limite de District" = "red"), # Colors for the legend
  ) +
  ggtitle("Neighborhoods and Limite de District in N'Djamena")+
  theme_void()

# Districts and Neighborhoods
ggplot()+
  geom_sf(data = districts, aes(color = "Districts"), fill= "grey", size = 6, alpha=0.5)+
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = "orange", size = 6, alpha = 0.1)+
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("Districts" = NA, "Neighborhoods" = "red"), # Colors for the legend
  ) +
  ggtitle("Districts and Neighborhoods in N'Djamena")+
  theme_void()

#geom_sf(data = hospitals_from_moh_sf, color = "pink", alpha = 0.5, size = 2) +






```


# Dividing the N'Djamena into Grids
``` {r}


# Use N'Djamena's name to get its bbox
ndjamena_bbox <- getbb("N'Djamena, Chad")
#print(ndjamena_bbox)
ndjamena_bbox <- matrix(
  data = c(ndjamena_bbox[1, 1]+0.03, ndjamena_bbox[1, 2] + 0.07, ndjamena_bbox[2, 1] - 0.1, ndjamena_bbox[2, 2] + 0.05),
  #data = c(ndjamena_bbox[1, 1] - 0.05, ndjamena_bbox[1, 2] + 0.05, ndjamena_bbox[2, 1] - 0.1, ndjamena_bbox[2, 2] + 0.05),
  nrow = 2,
  ncol = 2,
  byrow = T,
  dimnames = list(c('x','y'), c('min', 'max'))
)


# Convert bbox to an sf polygon
ndjamena_polygon <- st_as_sfc(st_bbox(
  c(xmin = ndjamena_bbox[1, "min"],
    ymin = ndjamena_bbox[2, "min"],
    xmax = ndjamena_bbox[1, "max"],
    ymax = ndjamena_bbox[2, "max"]),
  crs = 4326  # Assuming WGS84 CRS
)) 

# Convert sfc object to an sf object
ndjamena_sf <- st_sf(geometry = ndjamena_polygon)

# Step 1: Define the extent of the city (use city boundary or bounding box)
# Example: Using city boundary to define extent
city_boundary <- st_transform(ndjamena_sf, crs = 4326)  # Ensure CRS is in lat/lon
city_bbox <- st_bbox(city_boundary)  # Get the bounding box
  
# Step 2: Create a raster grid with 1km resolution
# Define the resolution in degrees (approx. 1km ~ 0.0089 degrees at the equator)
r <- raster(
  xmn = city_bbox["xmin"], xmx = city_bbox["xmax"],
  ymn = city_bbox["ymin"], ymx = city_bbox["ymax"],
  resolution = 0.0089  # Approx. 1km in degrees
  #resolution = 0.0156  # Approx. 3km in degrees
  #resolution = 0.0201  # Approx. 5km in degrees
  #resolution = 0.0238  # Approx. 7km in degrees
)

# Assign a unique ID to each grid cell
values(r) <- 1:ncell(r)

# Step 3: Convert the raster to polygons (optional, for use with ggplot or sf)
grid_polygons <- rasterToPolygons(r, dissolve = TRUE)
grid_sf <- st_as_sf(grid_polygons)
grid_sf <- st_set_crs(grid_sf, 4326)

# Plot all the grids over the city of N'Djamena while showing the boundary of the city
png("1km2 Grid Over the City of N'Djamena.png", width = 4000, height = 3000, res = 300)
ggplot() +
  geom_sf(data = grid_sf, fill = NA, color = "black", size = 0.5) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, size = 0.7, linewidth = 0.7) +
   scale_color_manual(
    name = "Legend", # Legend title
    values = c("City Boundary" = "red"), # Colors for the legend
  ) +
  ggtitle("1km² Grid Over the City of N'Djamena") +
  theme_minimal()+
   theme(
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm")  # Increase legend key size
  )
 dev.off() 
 
# Calculating the Centroids of all those grids
grid_centroids <- st_centroid(grid_sf)

# # Plotting ALL the grid centroids over the city boundary
# ggplot() +
#   geom_sf(data = grid_centroids, size = 3, fill = "blue", alpha = 0.5, inherit.aes = FALSE) +
#   geom_sf(data = ndjamena_boundary, fill = NA, color = "red", size = 1.2, inherit.aes = F) +
#   ggtitle("1km² Grid over N'Djamena with ALl the Grid Centroids") +
#   theme_minimal()

# How to restrict to only the grid centroids that are within the city boundary 
grid_sf_restricted <- filter_points_within_boundary(ndjamena_boundary, grid_centroids)



# Step 4: Plot the grid over the city boundary
a <- ggplot() +
  geom_sf(data = grid_sf_restricted, aes(color = "Centroids"), fill = NA, size = 1) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = "NA", size = 1.2, linewidth = 0.7) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Centroids" = "black", "City Boundary" = "red"), # Colors for the legend
  ) +
  ggtitle("1km² Grid Centroids Over the City of N'Djamena") +
  theme_void()+
   theme(
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm")  # Increase legend key size
  )
a
export_ggplot_as_png(a, "1km2 Grid Centroids Over the City of N'Djamena.png", width = 4000, height = 3000)

# #Step 10: Plot the grid, city boundary, and centroids
# png("1km2 Grid, Centroids and Boundary Over the City of N'Djamena.png", width = 4000, height = 3000, res = 300) 
# par(mar = c(5, 4, 4, 13))  # Bottom, Left, Top, Right margins
# plot(st_geometry(ndjamena_boundary), col = NA, border = "red", lwd = 2)  # City boundary
# plot(st_geometry(grid_sf), add = TRUE, col = NA, border = "blue", lwd = 0.5)  # Grid
# plot(st_geometry(grid_sf_restricted), add = TRUE, col = "black", pch = 20, cex = 0.7)  # Centroids
# 
# # Add Centered Bold Title
# title("1km x 1km Grid, Centroids and City Boundary", font.main = 2, cex.main = 2)
# 
# # Add Legend
# legend(x = "right",  # Moves legend to the right
#        inset = c(-0.25, 0),  # Moves it further right
#        legend = c(expression(bold("Legend")), "City Boundary", "Grid", "Centroids"),
#        col = c(NA, "red", "blue", "black"),  # NA for no color on "Legend"
#        lwd = c(NA, 2, 0.5, NA),  # No line for "Legend"
#        pch = c(NA, NA, NA, 20),  # No symbol for "Legend"
#        cex = 1.4,  # Increase legend text size
#        text.font = c(2, 1, 1, 1),  # Bold "Legend", normal others
#        pt.cex = 1.5,  # Increase size of centroid point
#        xpd = TRUE,  # Allows legend to go outside the plot
#        bty = "n")  # Remove legend box
 # dev.off()



 
 
 png("1km2 Grid, Centroids and Boundary Over the City of N'Djamena.png", width = 4000, height = 3000, res = 300) 

par(mar = c(5, 4, 4, 13))  # Bottom, Left, Top, Right margins

# Plot City Boundary
plot(st_geometry(ndjamena_boundary), col = NA, border = "red", lwd = 2)  # City boundary

# Plot Grid
plot(st_geometry(grid_sf), add = TRUE, col = NA, border = "blue", lwd = 0.5)  # Grid

# Plot Centroids
plot(st_geometry(grid_sf_restricted), add = TRUE, col = "black", pch = 20, cex = 0.7)  # Centroids

# Add Centered Bold Title
title("1km x 1km Grid, Centroids and City Boundary", font.main = 2, cex.main = 2)

# Add 1km Scale Bar (Manually)
scalebar_x <- min(st_coordinates(ndjamena_boundary)[,1]) - 0.01  # Adjust X position
scalebar_y <- min(st_coordinates(ndjamena_boundary)[,2]) + 0.01  # Adjust Y position

# Add Scale Bar
segments(x0 = scalebar_x, y0 = scalebar_y, x1 = scalebar_x + 0.01, y1 = scalebar_y, lwd = 3, col = "black")  # Scale bar line
text(x = scalebar_x + 0.005, y = scalebar_y - 0.01, labels = "1 km", cex = 1.5, font = 2)  # Scale bar label

# Add Legend
legend(x = "right",  # Moves legend to the right
       inset = c(-0.25, 0),  # Moves it further right
       legend = c(expression(bold("Legend")), "City Boundary", "Grid", "Centroids"),
       col = c(NA, "red", "blue", "black"),  # NA for no color on "Legend"
       lwd = c(NA, 2, 0.5, NA),  # No line for "Legend"
       pch = c(NA, NA, NA, 20),  # No symbol for "Legend"
       cex = 1.4,  # Increase legend text size
       text.font = c(2, 1, 1, 1),  # Bold "Legend", normal others
       pt.cex = 1.5,  # Increase size of centroid point
       xpd = TRUE,  # Allows legend to go outside the plot
       bty = "n")  # Remove legend box

dev.off()


# # Step 1: The contour of the city was determined manually from the neighborhoods and is "manual_contour_neighborhoods"
# ndjamena_boundary <- manual_contour_neighborhoods
# 
# # Step 2: Check the current CRS (likely EPSG:4326)
# st_crs(ndjamena_boundary)
# 
# # Step 3: Reproject to UTM (EPSG:32633 is commonly used for Chad)
# ndjamena_utm <- st_transform(ndjamena_boundary, 32633)  # UTM Zone 33N
# 
# # Step 4: Define the grid size (100m x 100m)
# grid_size <- 1000  # in meters
# grid <- st_make_grid(ndjamena_utm, cellsize = grid_size, what = "polygons")
# 
# # Step 4: Convert to sf object and clip to city boundary
# grid_sf <- st_sf(grid)
# grid_clipped <- st_intersection(grid_sf, ndjamena_utm)
# 
# # Step 5: Calculate centroids of each grid cell
# grid_centroids <- st_centroid(grid_clipped)
# 
# # Step 6: Extract centroid coordinates
# centroid_coords <- st_coordinates(grid_centroids) %>%
#   as.data.frame() %>%
#   rename(lon = X, lat = Y)
# 
# # Step 7: Convert back to WGS84 (Lat/Lon)
# grid_clipped_latlon <- st_transform(grid_clipped, 4326)
# grid_centroids_latlon <- st_transform(grid_centroids, 4326)
# 
# # Step 8: Save centroid coordinates to CSV
# write_csv(centroid_coords, "ndjamena_1000m_grid_centroids.csv")
# 
# # Step 9: Save the grid and centroids as shapefiles
# # st_write(grid_clipped_latlon, "ndjamena_100m_grid.shp")
# # st_write(grid_centroids_latlon, "ndjamena_100m_grid_centroids.shp")
# 
# 
# # Save high-resolution PNG
# png("ndjamena_grid.png", width = 4000, height = 3000, res = 300)  # 300 DPI resolution
# 
# Step 10: Plot the grid, city boundary, and centroids
# plot(st_geometry(ndjamena_boundary), col = NA, border = "red", lwd = 2)  # City boundary
# plot(st_geometry(grid_clipped_latlon), add = TRUE, col = NA, border = "blue", lwd = 0.5)  # Grid
# plot(st_geometry(grid_centroids_latlon), add = TRUE, col = "black", pch = 20, cex = 0.7)  # Centroids
# 
# # Add Centered Bold Title
# title("1km x 1km Grid and Centroids of N'Djamena", font.main = 2, cex.main = 2)
# 
# # Add Legend
# legend("topright",
#        legend = c("City Boundary", "Grid", "Centroids"),
#        col = c("red", "blue", "black"),
#        lwd = c(2, 0.5, NA),
#        pch = c(NA, NA, 20),
#        bty = "n")  # No box around the legend
# # Close the device and save the file
# dev.off()
# plot(grid_centroids)

```


# Population Data

```{r}
#______________________________________ POPULATION _____________________________________

# Specify the file path
worldpop_file <- '/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Data/Population/WorldPop/tcd_ppp_2020_UNadj_constrained.tif'

# Load the raster data
worldpop_raster <- raster(worldpop_file)

# Crop the WorldPop raster using the bounding box extent - we crop first, before masking, because it is a computationally expensive task. Masking will then allow us to further restrict the data to only show what is within the boundaries of the city
cropped_raster <- crop(worldpop_raster, ndjamena_sf)

plot(cropped_raster, main = "Population of N'Djamena within Bounding Box - WorlPop")

# Masking the cropped raster - to restric the data to the boundaries of N'Djamena
masked_raster <- mask(cropped_raster, manual_contour_neighborhoods)

# Convert the raster to a data frame for ggplot2
raster_df <- as.data.frame(masked_raster, xy = TRUE, na.rm = TRUE)


#_______________ VISUALIZING THE DATA ________________________________
# raster_df is the dataframe - Population Density - 100m x 100m resolution


# Plot the population distribution
q <- ggplot(raster_df, aes(x = x, y = y, fill = tcd_ppp_2020_UNadj_constrained)) +
  geom_sf(data = ndjamena_boundary, fill = NA, aes(color = "City Boundary"), size = 1.2, linewidth = 1, inherit.aes = F) +
  geom_tile() +
  scale_fill_viridis_c(option = "plasma", name = "Population") +  # Set "magma" color scale
   # Manually define the City Boundary color in the legend
  scale_color_manual(name = "Legend", values = c("City Boundary" = "red")) +
  theme_void() +
  labs(title = "Population Distribution in N'Djamena - WorldPop - 100m x 100m", fill = "Population") +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  )



export_ggplot_as_png(q, "Population Distribution in N'Djamena - WorldPop - 100m x 100m.png")

q<- q + labs(title = "a) Population Distribution in N'Djamena - WorldPop - 100m x 100m")

# # Converting the dataframe raster_df into a spatial object sf
raster_sf <- st_as_sf(raster_df, coords = c("x", "y"), crs = 4326)


# mapview(raster_sf)

#______________ CONVERTING TO LARGER GRIDS FROM 100M X 100M TO 1KM2_________________________________
# Converting raster_df from 100m x 100m resolution to the 1 km2 grids that we already have


# Perform spatial join to assign each 100m cell to a 1km grid cell
raster_grid_joined <- st_join(raster_sf, grid_sf, join = st_within)


# Aggregate population density by summing within each 1km cell
pop_1km_sf <- raster_grid_joined %>%
  group_by(layer) %>%  # Assuming `grid_id` is the unique identifier for 1km grid cells
  summarise(population = sum(tcd_ppp_2020_UNadj_constrained, na.rm = TRUE)) %>%
  ungroup()

# Step 4: Ensure grid_sf and population data are merged correctly
pop_1km_sf <- st_join(grid_sf, pop_1km_sf, join = st_contains) %>%  # Merge back to grid polygons
 select(-layer.y) %>%  # Remove duplicate grid_id if created
  filter(!is.na(population)) %>%
  rename(layer = layer.x) %>%
  st_as_sf()  # Ensure it remains an sf object


# Visualizing the data in a tile format

# Convert pop_1km_sf to a dataframe with coordinates
pop_1km_df <- pop_1km_sf %>%
  cbind(st_coordinates(st_centroid(.))) %>%  # Extract centroids for plotting
  st_drop_geometry()  # Remove geometry to use in geom_tile()





# Plot population density with geom_tile
w <- ggplot() +
  # Population density as raster (ensure it appears first in the legend)
  geom_tile(data = pop_1km_df, aes(x = X, y = Y, fill = population)) +
  
  # Overlay city boundary with a legend entry
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
  
  # Color scale for population density (ensures it appears first)
  scale_fill_viridis_c(name = "Population", option = "plasma") +
  
  # Manually define the color for the City Boundary in the legend
  scale_color_manual(
    name = "Legend", 
    values = c("City Boundary" = "red")  # Assigns red color to city boundary in legend
  ) +
  
  # Define legend order: Population scale first, then City Boundary
  guides(
    fill = guide_colorbar(order = 1),  # Population scale first
    color = guide_legend(order = 2)    # City Boundary second
  ) +

  # Theme settings
  theme_void() +
  labs(title = "Population Distribution in N'Djamena - World Pop - 1km x 1km") +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  )

# Display the plot
w

export_ggplot_as_png(w, "Population Distribution in N'Djamena - World Pop - 1km x 1km.png")


   
#Exporting side by side png
w<- w + labs(title = "b) Population Distribution in N'Djamena - World Pop - 1km x 1km")
q<- q + labs(title = "a) Population Distribution in N'Djamena - WorldPop - 100m x 100m")
export_ggplot_as_png(q+w, "Population Distribution 100m and 1km.png", width = 6500, height = 2800)

# Population of N'Djamena based on city boundary and World Pop data
Ndjamena_population <- raster_df %>%
  summarise(total = sum(tcd_ppp_2020_UNadj_constrained), na.rm = TRUE)

```
# List of Hospitals from Ministry of Health (2020)

```{r}

# # Save high-resolution PNG
# png("ndjamena_grid.png", width = 4000, height = 3000, res = 300)  # 300 DPI resolution
# # Close the device and save the file
# dev.off()

# Load the Excel file
hospitals_from_moh <- read_excel('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Hospitals/tcd_data_listecdsdistrictssanitaires_msp_2020.xlsx')


# View the first few rows
head(hospitals_from_moh)

# Piping to show only the hospitals in N'Djamena
hospitals_from_moh <- hospitals_from_moh %>%
  filter(NomProvince == "N'Djamena")

# Remove hospital provincial Hôpital Provincial
hospitals_from_moh <- hospitals_from_moh %>%
  filter(TYPES != "Hôpital Provincial")

# Remove HRGN (Hopital General de Reference National)
hospitals_from_moh <- hospitals_from_moh %>%
  filter(Nom != "Hgrn")

# Translating the TYPES into English
hospitals_from_moh <- hospitals_from_moh %>%
  mutate(TYPES = case_when(
    TYPES == "Centre de santé" ~ "Health Center",
    TYPES == "Hôpital de district" ~ "District Hospital",
    TYPES == "Hôpital National" ~ "National Hospital"
  ))



# Changing the columns name of longitude and latitude
hospitals_from_moh <- hospitals_from_moh %>%
  rename(longitude = LONGITUDE, latitude = LATITUDE)

# Convert data to sf object
hospitals_from_moh_sf <- st_as_sf(hospitals_from_moh, coords = c("longitude", "latitude"), crs = 4326)

# Remove the hospitals that are not within the city boundary
hospitals_from_moh_sf <- filter_points_within_boundary(ndjamena_boundary, hospitals_from_moh_sf)

# Separate the different hospitals in different dataframes
# Health Center
healthcenter <-  hospitals_from_moh_sf %>%
  filter(TYPES == "Health Center")
# District Hospital
districthospital <-  hospitals_from_moh_sf %>%
  filter(TYPES == "District Hospital")
# National Hospital
nationalhospital <-  hospitals_from_moh_sf %>%
  filter(TYPES == "National Hospital")


# Count the number of each hospital type
hospital_counts <- hospitals_from_moh_sf %>%
  count(TYPES)

# View the result
print(hospital_counts)


# Save high-resolution PNG
png("Hospitals in NDjamena.png", width = 4000, height = 3000, res = 300)  # 300 DPI resolution
# Plotting all hospitals
ggplot()+
  geom_sf(data = hospitals_from_moh_sf, aes(color = "Hospitals"), fill= "red", size = 3, alpha=0.5)+
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill= "NA", size = 3, alpha=1, linewidth = 1)+
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, linewidth = 0.3, alpha = 0.5) +
    scale_color_manual(
    name = "Legend", # Legend title
    values = c("Hospitals" = "black", "City Boundary" = "red"), # Colors for the legend
  ) +
  ggtitle("Hospitals in N'Djamena")+
  theme_void()+
  theme(
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm")  # Increase legend key size
  )
# Close the device and save the file
dev.off()



# Plotting all hospitals by TYPE
png("Hospitals in NDjamena BY TYPE.png", width = 4000, height = 3000, res = 300)  # 300 DPI resolution
ggplot() +
  # Add hospitals with colors based on Type
  geom_sf(data = hospitals_from_moh_sf, aes(color = TYPES), size = 6, alpha = 0.5) +
  # Add city boundary in red
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, linewidth = 0.3, alpha = 0.5) +
  # Custom legend and colors
  scale_color_manual(
    name = "Legend", # Legend title
    values = c(
      "Health Center" = "black", "District Hospital" = "blue", "National Hospital" = "red", "City Boundary" = "black", "Neighborhoods" = "grey"), # Adjust hospital type colors as needed
    limits = c("National Hospital", "District Hospital", "Health Center", "Neighborhoods", "City Boundary"),
  ) +
  
  # Title and theme
  ggtitle("Hospitals in N'Djamena by Type") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14), # Centered title
    legend.position = "right", # Move legend to the right
    legend.text = element_text(size = 14),  # Increase legend text size
    legend.title = element_text(size = 16, face = "bold"),  # Increase legend title size
    legend.key.size = unit(1.5, "cm")  # Increase legend key size
  )
dev.off()




```
# Calculating Travel Times & Generating the Plots
Calculate by car, motorcycle, walking and bicycle

## Distances and Travel Times & Distances for the Various Travel Modes

```{r}



#______________________ CORRECTION FACTOR ____________________________________

# Google API Key (replace with your actual key)
google_api_key <- ""

# Define the departure time: Monday, March 24th, 2025, 11:00 AM N'Djamena Time
departure_time <- as.integer(as.POSIXct("2025-03-24 11:00:00", tz = "Africa/Ndjamena"))

# Extract origin points (grid_sf_restricted)
origin_coords <- st_coordinates(grid_sf_restricted)
origin_layers <- grid_sf_restricted$layer

# Extract hospital coordinates (Hn Mere Enfant (Hme))
hospital_coords <- st_coordinates(hospitals_from_moh_sf %>% filter(Nom == "Hn Mere Enfant (Hme)"))

# Ensure hospital exists
if (nrow(hospital_coords) == 0) stop("Hospital not found!")

# Convert to proper list format
origin_list <- split(origin_coords, seq(nrow(origin_coords))) %>% lapply(as.numeric)
destination_list <- list(as.numeric(hospital_coords))

### **🔹 Step 1: Get Travel Time from ORS** ###
travel_matrix_ors <- tryCatch({
  ors_matrix(
    locations = c(origin_list, destination_list),
    sources = seq(1, length(origin_list)) - 1,
    destinations = length(origin_list),
    profile = "driving-car",
    metrics = c("duration"),  
    units = "m"  # ✅ Time in minutes
  )
}, error = function(e) {
  message("ORS request failed: ", e$message)
  return(NULL)
})

# Convert ORS travel time from seconds to minutes
if (!is.null(travel_matrix_ors)) {
  travel_time_ors <- travel_matrix_ors$durations[, 1] / 60  # ✅ Convert seconds to minutes
} else {
  travel_time_ors <- rep(NA, length(origin_list))  # Handle failure case
}

### **🔹 Step 2: Get Travel Time from Google API** ###
get_google_travel_info_httr2 <- function(departure_lon, departure_lat, dest_lon, dest_lat, method) {
  
  # Map transportation methods
  mode_map <- list(
    "car" = "driving",
    "motorcycle" = "driving",
    "bicycle" = "bicycling",
    "walking" = "walking"
  )
  
  # Use correct mode or default to "driving"
  mode <- mode_map[[method]]
  if (is.null(mode)) mode <- "driving"
  
  # Construct API request
  url <- paste0("https://maps.googleapis.com/maps/api/distancematrix/json?",
                "origins=", departure_lat, ",", departure_lon,
                "&destinations=", dest_lat, ",", dest_lon,
                "&mode=", mode,
                "&departure_time=", departure_time, 
                "&key=", google_api_key)

  # Send API request with httr2
  response <- request(url) |> req_perform()
  
  # Parse JSON response
  data <- response |> resp_body_json()

  # Extract travel time & distance
  if (data$status == "OK" && data$rows[[1]]$elements[[1]]$status == "OK") {
    travel_time <- data$rows[[1]]$elements[[1]]$duration$value / 60  # Convert to minutes
    distance <- data$rows[[1]]$elements[[1]]$distance$value / 1000  # Convert to km
    return(c(travel_time, distance))
  } else {
    return(c(NA, NA))  # Return NA if request fails
  }
}

# Get Google Maps travel times
travel_time_google <- map(origin_list, ~ get_google_travel_info_httr2(.x[1], .x[2], hospital_coords[1], hospital_coords[2], "car")) %>%
  transpose() %>% 
  map(unlist)

# Extract travel times from Google API
travel_time_google_min <- travel_time_google[[1]]  # First element is travel time in minutes

### **🔹 Step 3: Store Data in a DataFrame** ###
travel_time_df <- data.frame(
  layer = origin_layers,
  longitude = origin_coords[, 1],
  latitude = origin_coords[, 2],
  travel_time_ors_min = travel_time_ors,
  travel_time_google_min = travel_time_google_min
)

# Drop rows with missing data
travel_time_df <- travel_time_df %>% drop_na(travel_time_google_min, travel_time_ors_min)

### **🔹 Step 4: Compute Correction Factor** ###
Correction_Factor <- mean(travel_time_df$travel_time_google_min / travel_time_df$travel_time_ors_min, na.rm = TRUE)

# Print Correction Factor
print(paste("Correction Factor for ORS Travel Time:", round(Correction_Factor, 2)))

# Save results
write.csv(travel_time_df, "travel_time_comparison.csv", row.names = FALSE)




#____________________ VISUALIZING THE CORRECTION FACTOR __________________


# Load the dataset
travel_time_df <- read.csv("travel_time_comparison.csv")

# Compute correction factor
Correction_Factor <- mean(travel_time_df$travel_time_google_min / travel_time_df$travel_time_ors_min, na.rm = TRUE)

# Create scatter plot with matching font sizes
comparison_plot <- ggplot(travel_time_df, aes(x = travel_time_ors_min, y = travel_time_google_min)) +
  geom_point(aes(color = "Data Points"), alpha = 0.5, size = 3) +  # Scatter points
  geom_abline(aes(slope = 1, intercept = 0, color = "1:1 Reference Line"), linetype = "dashed", size = 1) +  # Reference line
  labs(
    title = "Comparison of ORS vs Google Maps Travel Times",
    x = "ORS Travel Time (min)",
    y = "Google Maps Travel Time (min)",
    color = "Legend"
  ) +
  theme_minimal() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  scale_color_manual(values = c("Data Points" = "blue", "1:1 Reference Line" = "red")) +  # Custom colors
  annotate("text", 
           x = max(travel_time_df$travel_time_ors_min, na.rm = TRUE) * 0.6, 
           y = max(travel_time_df$travel_time_google_min, na.rm = TRUE) * 0.9, 
           label = paste("Mean Correction Factor:", round(Correction_Factor, 2)), 
           size = 6, color = "black", fontface = "bold")



# Save the plot as PNG
export_ggplot_as_png(comparison_plot, "ORS_vs_Google_Travel_Time_Comparison.png")





#______________________ORS MATRIX CALCULATIONS ____________________

# Convert origin and destination points to coordinate lists
origin_coords <- st_coordinates(grid_sf_restricted)

# Extract the layer IDs of the origin points and rename it as 'layer'
origin_layers <- grid_sf_restricted$layer  

# Convert to proper list format
origin_list <- split(origin_coords, seq(nrow(origin_coords))) %>% 
  lapply(function(x) as.numeric(x))  # Ensure proper numeric vector

# Define batch size (40 at a time)
batch_size <- 40

# Define transportation modes
transport_modes <- c("driving-car", "cycling-regular", "foot-walking")

# Define hospital type cases
hospital_cases <- list(
  "National Hospitals Only" = hospitals_from_moh_sf %>% filter(TYPES == "National Hospital"),
  "National and District" = hospitals_from_moh_sf %>% filter(TYPES %in% c("National Hospital", "District Hospital")),
  "All Hospitals" = hospitals_from_moh_sf
)

# Create an empty list to store results
distance_results_list <- list()

# Process for each transport mode
for (mode in transport_modes) {
  message("Processing mode: ", mode)
  
  for (case_name in names(hospital_cases)) {
    
    # Select hospitals based on the case
    selected_hospitals <- hospital_cases[[case_name]]
    destination_coords <- st_coordinates(selected_hospitals)

    # Convert to proper list format
    destination_list <- split(destination_coords, seq(nrow(destination_coords))) %>% 
      lapply(function(x) as.numeric(x))

    # Create an empty dataframe to store results
    distance_results <- data.frame(
      layer = integer(),  
      longitude = numeric(),  
      latitude = numeric(),   
      nearest_hospital_distance_km = numeric(),
      nearest_hospital_travel_time_min = numeric(),
      nearest_hospital_id = integer(),
      nearest_hospital_name = character(),
      transport_mode = character(),
      hospital_case = character()
    )

    # Process in batches
    for (i in seq(1, length(origin_list), by = batch_size)) {
      
      # Select the batch of origins
      batch_origins <- origin_list[i:min(i + batch_size - 1, length(origin_list))]
      batch_layers <- origin_layers[i:min(i + batch_size - 1, length(origin_list))]  # Extract corresponding layer IDs
      
      # Combine batch origins + all hospital destinations
      locations <- c(batch_origins, destination_list)  # Ensuring correct format
      
      # Compute indexing for ORS Matrix
      num_origins <- length(batch_origins)
      num_destinations <- length(destination_list)
      
      # Call ORS matrix function for distance and duration
      travel_matrix <- tryCatch({
        ors_matrix(
          locations = locations,
          sources = seq(1, num_origins) - 1,  
          destinations = seq(num_origins + 1, num_origins + num_destinations) - 1,  
          profile = mode,
          metrics = c("distance", "duration"),  
          units = "km"
        )
      }, error = function(e) {
        message("ORS request failed: ", e$message)
        return(NULL)
      })
      
      # Skip iteration if API request failed
      if (is.null(travel_matrix)) next
      
      # Extract the matrices of distances & durations
      distance_matrix <- travel_matrix$distances  
      duration_matrix <- travel_matrix$durations  
      
      # Find the nearest hospital for each origin
      for (j in 1:nrow(distance_matrix)) {
        min_distance <- min(distance_matrix[j, ], na.rm = TRUE)  
        min_duration <- min(duration_matrix[j, ], na.rm = TRUE)  
        nearest_hospital_index <- which.min(distance_matrix[j, ])  

        # Extract the coordinates of the current origin
        origin_longitude <- batch_origins[[j]][1]
        origin_latitude <- batch_origins[[j]][2]
        
        # Adjust travel time for driving-car using the correction factor
        adjusted_travel_time <- min_duration / 60  # Convert seconds to minutes
        if (mode == "driving-car") {
          adjusted_travel_time <- adjusted_travel_time * Correction_Factor
        }

        # Append result
        distance_results <- rbind(
          distance_results, 
          data.frame(
            layer = batch_layers[j],  
            longitude = origin_longitude,  
            latitude = origin_latitude,    
            nearest_hospital_distance_km = min_distance,
            nearest_hospital_travel_time_min = adjusted_travel_time,  
            nearest_hospital_id = nearest_hospital_index,
            nearest_hospital_name = selected_hospitals$Nom[nearest_hospital_index],  
            transport_mode = mode,
            hospital_case = case_name
          )
        )
      }
      
      # Print progress
      message("Processed batch ", i, " to ", min(i + batch_size - 1, length(origin_list)), " for mode ", mode, " and case ", case_name)
    }
    
    # Store results in a unique dataset
    dataset_name <- paste0(mode, "_", case_name)
    distance_results_list[[dataset_name]] <- distance_results
  }
}

# View results for one of the datasets
head(distance_results_list[["driving-car_National Hospitals Only"]])

# -----------------------------------------------
# **Motorcycle Case (Using Car Travel Time)**
# -----------------------------------------------
Coefficient_Car_to_Motorcycle <- 0.85  

# Iterate over the three "driving-car" lists and create equivalent "motorcycle" datasets
for (hospital_case in c("National Hospitals Only", "National and District", "All Hospitals")) {
  
  # Extract the corresponding car dataset
  car_data <- distance_results_list[[paste0("driving-car_", hospital_case)]]

  # Create a copy of the car data for motorcycles
  motorcycle_data <- car_data

  # Modify the transport mode
  motorcycle_data$transport_mode <- "motorcycle"

  # Adjust travel time by applying the correction coefficient
  motorcycle_data$nearest_hospital_travel_time_min <- car_data$nearest_hospital_travel_time_min * Coefficient_Car_to_Motorcycle  

  # Store the modified dataset in the list with a new name for motorcycles
  distance_results_list[[paste0("motorcycle_", hospital_case)]] <- motorcycle_data
}

# View the updated list of datasets
names(distance_results_list)




```

## Heatmap per 1km2 Grid, Neighborhood and Cumulative Percent
``` {r}

#________________________________ GENERATING 1KM2 TRAVEL TIME GRID HEAT MAPS _____________________________________

# Define the base directory for storing plots
base_dir <- "Travel_Time_Heatmaps_1km_Grid"

# Ensure the base directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Loop through each dataset in the list and generate a heatmap
for (dataset_name in names(distance_results_list)) {
  
  # Extract the data for the current transport mode and hospital case
  travel_data <- distance_results_list[[dataset_name]]
  
  # Ensure the dataset has valid longitude, latitude, and travel time
  if (!all(c("longitude", "latitude", "nearest_hospital_travel_time_min") %in% colnames(travel_data))) {
    next  # Skip this dataset if required columns are missing
  }
  
  # Extract transport mode from dataset name
  transport_mode <- strsplit(dataset_name, "_")[[1]][1]
  
  # Define the directory for this transport mode
  mode_dir <- file.path(base_dir, transport_mode)
  
  # Ensure the transport mode directory exists
  if (!dir.exists(mode_dir)) {
    dir.create(mode_dir, recursive = TRUE)
  }
  
  # Generate the heatmap
  heatmap_plot <- ggplot() +
    # Raster layer: Travel time using geom_tile()
    geom_tile(data = travel_data, 
              aes(x = longitude, y = latitude, fill = nearest_hospital_travel_time_min)) +
    
    # Overlay city boundary in black (ensure it's an sf object)
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    
    # Define color scale for travel time
    scale_fill_viridis(name = "Travel Time (min)", option = "plasma") +
    
    # Manually define color for city boundary in legend
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    
    # Add title
    ggtitle(paste("Travel Time Heatmap for", dataset_name)) +
    
    # Adjust theme
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )
  
  # Display the plot
  print(heatmap_plot)
  
  # Define the file path for saving the plot
  file_path <- file.path(mode_dir, paste0(dataset_name, "_heatmap.png"))
  
  # Save the plot as a PNG file
  export_ggplot_as_png(heatmap_plot, file_path)
}


#-------------------------- GENERATING 1KM2 GRID TRAVEL TIME HEAT MAPS WITH **NEIGHBORHOODS** _______________________



# Define the base directory for storing heatmaps
base_dir <- "Travel_Time_Heatmaps_With_Neighborhoods_1km_Grid"

# Ensure the base directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Loop through each dataset in the list and generate a heatmap
for (dataset_name in names(distance_results_list)) {
  
  # Extract the data for the current transport mode and hospital case
  travel_data <- distance_results_list[[dataset_name]]

  # Ensure the dataset has valid longitude, latitude, and travel time
  if (!all(c("longitude", "latitude", "nearest_hospital_travel_time_min") %in% colnames(travel_data))) {
    next  # Skip this dataset if required columns are missing
  }

  # Extract transport mode from dataset name
  transport_mode <- strsplit(dataset_name, "_")[[1]][1]
  
  # Define the directory for this transport mode
  mode_dir <- file.path(base_dir, transport_mode)
  
  # Ensure the transport mode directory exists
  if (!dir.exists(mode_dir)) {
    dir.create(mode_dir, recursive = TRUE)
  }

  # Generate the heatmap
  heatmap_plot <- ggplot() +
    # Raster layer: Travel time using geom_tile()
    geom_tile(data = travel_data, 
              aes(x = longitude, y = latitude, fill = nearest_hospital_travel_time_min)) +
    
    # Overlay city boundary in black (ensure it's an sf object)
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    
    geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, linewidth = 1, alpha = 1) +
    
    # Define color scale for travel time
    scale_fill_viridis(name = "Travel Time (min)", option = "plasma") +
    
    # Manually define color for city boundary in legend
    scale_color_manual(name = "Legend", values = c("Neighborhoods" = "black")) +
    
    # Add title
    ggtitle(paste("Travel Time Heatmap with Neighborhoods for", dataset_name)) +
    
    # Adjust theme
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )
  
  # Display the plot
  print(heatmap_plot)

  # Define the file path for saving the plot
  file_path <- file.path(mode_dir, paste0(dataset_name, "_with_neighborhoods_heatmap.png"))

  # Save the plot as a PNG file
  export_ggplot_as_png(heatmap_plot, file_path)
}


#-------------------------- GENERATING 1KM2 GRID TRAVEL TIME HEAT MAPS WITH **NEIGHBORHOODS** Cut-off at 60 minutes _______________________


# Define the base directory for storing heatmaps with fixed scale
base_dir <- "Travel_Time_Heatmaps_With_Neighborhoods_1km_Grid_fixed"

# Ensure the base directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Loop through each dataset in the list and generate a heatmap
for (dataset_name in names(distance_results_list)) {
  
  # Extract the data for the current transport mode and hospital case
  travel_data <- distance_results_list[[dataset_name]]
  
  # Ensure the dataset has valid longitude, latitude, and travel time
  if (!all(c("longitude", "latitude", "nearest_hospital_travel_time_min") %in% colnames(travel_data))) {
    next  # Skip this dataset if required columns are missing
  }
  
  # Extract transport mode from dataset name
  transport_mode <- strsplit(dataset_name, "_")[[1]][1]
  
  # Define the directory for this transport mode
  mode_dir <- file.path(base_dir, transport_mode)
  
  # Ensure the transport mode directory exists
  if (!dir.exists(mode_dir)) {
    dir.create(mode_dir, recursive = TRUE)
  }
  
  # Generate the heatmap with a fixed scale (0 to 60 minutes)
  heatmap_plot <- ggplot() +
    # Raster layer: Travel time using geom_tile()
    geom_tile(data = travel_data, 
              aes(x = longitude, y = latitude, fill = nearest_hospital_travel_time_min)) +
    
    # Overlay city boundary in black
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    
    # Overlay neighborhoods outlines
    geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, linewidth = 1, alpha = 1) +
    
    # Define fixed color scale for travel time from 0 to 60 minutes
    scale_fill_viridis(name = "Travel Time (min)", option = "plasma", limits = c(0, 60)) +
    
    # Define manual color for city boundary in legend
    scale_color_manual(name = "Legend", values = c("Neighborhoods" = "black", "City Boundary" = "black")) +
    
    # Add title
    ggtitle(paste("Travel Time Heatmap with Neighborhoods for", dataset_name)) +
    
    # Adjust theme settings
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )
  
  # Display the plot
  print(heatmap_plot)
  
  # Define the file path for saving the plot
  file_path <- file.path(mode_dir, paste0(dataset_name, "_with_neighborhoods_heatmap.png"))
  
  # Save the plot as a PNG file using your custom export function
  export_ggplot_as_png(heatmap_plot, file_path)
}




#-------------------------- GENERATING 1KM2 GRID TRAVEL DISTANCE HEAT MAPS WITH **NEIGHBORHOODS** _______________________

# Define the base directory for storing hospital distance heatmaps
base_dir <- "Hospital_Distance_Heatmaps"

# Ensure the base directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Extract unique hospital cases (ignoring transport modes)
hospital_cases <- unique(gsub(".*_", "", names(distance_results_list)))

# Iterate over each hospital case and generate a heatmap
for (case_name in hospital_cases) {
  
  # Select the dataset corresponding to the hospital case (ignoring transport mode)
  matching_datasets <- grep(case_name, names(distance_results_list), value = TRUE)
  
  # Combine all datasets for the hospital case (since transport mode doesn't matter for distance)
  combined_data <- do.call(rbind, distance_results_list[matching_datasets])
  
  # Ensure dataset contains necessary columns
  if (!all(c("longitude", "latitude", "nearest_hospital_distance_km") %in% colnames(combined_data))) {
    next  # Skip if required columns are missing
  }

  # Define the folder path for this hospital case
  case_dir <- file.path(base_dir, gsub(" ", "_", case_name))
  
  # Ensure the directory exists
  if (!dir.exists(case_dir)) {
    dir.create(case_dir, recursive = TRUE)
  }

  # Dynamically determine min & max hospital distances for this dataset
  min_distance <- min(combined_data$nearest_hospital_distance_km, na.rm = TRUE)
  max_distance <- max(combined_data$nearest_hospital_distance_km, na.rm = TRUE)

  # Generate the heatmap
  heatmap_plot <- ggplot() +
    # Raster layer: Distance to nearest hospital using geom_tile()
    geom_tile(data = combined_data, 
              aes(x = longitude, y = latitude, fill = nearest_hospital_distance_km)) +
    
    # Overlay city boundary
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    
    # Overlay neighborhoods
    geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, linewidth = 1, alpha = 1) +
    
    # Define color scale dynamically based on dataset's min/max distances
    scale_fill_viridis(name = "Distance to Hospital (km)", option = "plasma", limits = c(min_distance, max_distance)) +
    
    # Define colors for the city boundary and neighborhoods
    scale_color_manual(name = "Legend", values = c("Neighborhoods" = "black")) +
    
    # Add title
    ggtitle(paste("Hospital Distance Heatmap for", case_name)) +
    
    # Adjust theme
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )
  
  # Display the plot
  print(heatmap_plot)
  
  # Define the file path for saving the plot
  file_path <- file.path(case_dir, paste0("Hospital_Distance_", gsub(" ", "_", case_name), "_heatmap.png"))
  
  # Save the plot as a PNG file
  export_ggplot_as_png(heatmap_plot, file_path)
}

#_________ INTERACTIVE TRAVEL DISANCE HEAT MAP______________________________________

# Define base directory for interactive maps
base_dir <- "Hospital_Distance_Interactive_Maps"

# Ensure the directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Define color palette (0 to 25 km consistent scale)
color_pal <- colorNumeric(palette = "plasma", domain = c(0, 25))

# Extract unique hospital cases (ignore transport mode)
hospital_cases <- unique(gsub(".*_", "", names(distance_results_list)))

# Iterate over each hospital case and create an interactive map
for (case_name in hospital_cases) {
  
  # Select relevant datasets (since transport mode doesn't matter for distance)
  matching_datasets <- grep(case_name, names(distance_results_list), value = TRUE)
  
  # Combine all datasets for the hospital case
  combined_data <- do.call(rbind, distance_results_list[matching_datasets])
  
  # Ensure necessary columns exist
  if (!all(c("longitude", "latitude", "nearest_hospital_distance_km") %in% colnames(combined_data))) {
    next  # Skip if columns are missing
  }

  # Convert data into sf object for leaflet
  combined_sf <- st_as_sf(combined_data, coords = c("longitude", "latitude"), crs = 4326)

  # Create an interactive map using leaflet
  interactive_map <- leaflet() %>%
    addProviderTiles("CartoDB.Positron") %>%  # Add a base map
    addPolygons(data = neighborhoods, color = "black", weight = 1, fill = NA, group = "Neighborhoods") %>%  # Overlay neighborhoods
    addPolylines(data = ndjamena_boundary, color = "red", weight = 2, group = "City Boundary") %>%  # Add city boundary
    addCircles(data = combined_sf,
               color = ~color_pal(nearest_hospital_distance_km),
               fillColor = ~color_pal(nearest_hospital_distance_km),
               fillOpacity = 0.7,
               radius = 100,  # Adjust radius for better visualization
               popup = ~paste0("<b>Distance to Nearest Hospital:</b> ", round(nearest_hospital_distance_km, 2), " km"),
               label = ~paste0(round(nearest_hospital_distance_km, 2), " km")) %>%
    addLegend(pal = color_pal, values = combined_sf$nearest_hospital_distance_km,
              title = "Distance to Hospital (km)", opacity = 1) %>%
    addLayersControl(overlayGroups = c("Neighborhoods", "City Boundary"), options = layersControlOptions(collapsed = FALSE))
  
  # Define folder for this hospital case
  case_dir <- file.path(base_dir, gsub(" ", "_", case_name))
  
  # Ensure the case-specific folder exists
  if (!dir.exists(case_dir)) {
    dir.create(case_dir, recursive = TRUE)
  }

  # Define the HTML filename inside the folder
  html_filename <- file.path(case_dir, paste0("Hospital_Distance_", gsub(" ", "_", case_name), "_interactive.html"))
  
  # Save the map as an HTML file
  saveWidget(interactive_map, file = html_filename, selfcontained = TRUE)
  
  # Print message to confirm
  message("Saved interactive map: ", html_filename)
}

#_____________________________CREATING FAKE TRAVEL TIMES ____________________________________


# #Extract coordinates (from the centroids within the boundary - grid_sf_restricted)
# coordinates <- st_coordinates(grid_sf_restricted, crs = 4326)
# 
# # Create fake results travel time
# fake_results <- data.frame(
#   id = grid_sf_restricted$layer,  # Keep an identifier column if available
#   longitude = coordinates[, 1],
#   latitude = coordinates[, 2]
# )
# 
# # Adding fake travel time
# fake_results$travel_time <-  runif(nrow(fake_results), min = 0, max = 30)


#_________________ PLOTTING THE TRAVEL TIME RESULTS __________________________
# 
#   # To use geom_tile(), the data needs to be a dataframe
#   png("Fake City Travel Time Heat Map.png", width = 4000, height = 3000, res = 300) 
#   ggplot() +
#     # Raster layer: Travel time using geom_tile()
#     geom_tile(data = fake_results, aes(x = longitude, y = latitude, fill = travel_time)) +
#     
#     # Overlay city boundary in black (ensure it's an sf object)
#     geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
#     
#     # Define color scale for travel time
#     scale_fill_viridis(name = "Travel Time (min)", option = "plasma")+
#     #scale_fill_gradient(low = "yellow", high = "red", name = "Travel Time (min)") +
#      # Manually define color for city boundary in legend
#     scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
#     
#     # Add title
#     ggtitle("Raster Plot of Fake Travel Time in N'Djamena") +
#     
#     # Adjust theme
#     theme_void() +
#     theme(
#       legend.text = element_text(size = 14),
#       legend.title = element_text(size = 16, face = "bold"),
#       plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
#     )
#     dev.off()


#_________________ HEAT MAP PER NEIGHBORHOOD ___________________________________

# Checking the CRS 
st_crs(grid_sf_restricted)  # Check CRS of centroids
st_crs(neighborhoods)  # Check CRS of neighborhood polygons

# Converting to the same CRS
neighborhoods <- st_transform(neighborhoods, st_crs(grid_sf_restricted))

# Ensuring CRS's are the same
st_crs(grid_sf_restricted) == st_crs(neighborhoods)  # Should return TRUE


# Perform a spatial join to match grid centroids with their corresponding neighborhood - lists for each centroid point which neigbhorhood it belongs to
grid_with_neighborhoods <- st_join(grid_sf_restricted, neighborhoods)


#________________ 1ST INVESTIGATION POINTS NOT BELONGING TO ANY NEIGHBORHOOD__________________________


# Which centroids are missing neighborhoods
missing_data_points <- grid_with_neighborhoods %>%
  filter(is.na(NOM))

png("Centroids Not Belonging to a Neighborhood.png", width = 4000, height = 3000, res = 300)
# Plot the neighborhoods along with the missing centroids
ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5) +
  geom_sf(data = missing_data_points, aes(color = "Centroids"), size = 5, alpha = 0.7)+
  #geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) + # City Boundary
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = "NA", size = 1.2, linewidth = 0.7) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black", "Centroids" = "red", "City Boundary" = "black"), # "City Boundary" = "purple"), # Colors for the legend
    limits = c("Neighborhoods", "Centroids", "City Boundary")  # Custom order
  ) +
 theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )+
  ggtitle("Centroids Not Belonging to a Neighborhood")
dev.off()




# Remove the points that don't belong to a neighborhood
grid_with_neighborhoods <- grid_with_neighborhoods %>%
  filter(!is.na(NOM))


#_____________ 2ND INVESTIGATION ___________________________________________
# Plot the various centroids belonging to each neighborhood
# Neighborhoods Djambalbahr, Mardjandafak and Ambassatna don't have a centroid in them, so don't show any aggregated data when showing travel time by neighborhood.

p1 <- ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5) +
  geom_sf(data = grid_with_neighborhoods, aes(color = "Centroids"), size = 1, alpha = 0.7)+
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = "NA", size = 1.2, linewidth = 0.7) +
  scale_color_manual(
    name = "Legend", # Legend title
    values = c("Neighborhoods" = "black", "City Boundary" = "black", "Centroids" = "red"), # "City Boundary" = "purple"), # Colors for the legend
    limits = c("Neighborhoods", "City Boundary", "Centroids")  # Custom order
  ) +
 theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )+
  ggtitle("Centroids Belonging to a Neighborhood")

p1
export_ggplot_as_png(p1, "Centroids Belonging to a Neighborhood.png")






# Identify neighborhoods without centroids
neighborhoods_no_centroids <- neighborhoods %>%
  mutate(has_centroid = lengths(st_intersects(., grid_with_neighborhoods)) > 0) %>%
  filter(has_centroid == FALSE)

# Plot neighborhoods without centroids shaded in burgundy
plot_no_centroids <- ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), size = 0.1, alpha = 0.5, fill = NA) +
  geom_sf(data = neighborhoods_no_centroids, aes(fill = "No Travel Time"), color = "black", size = 0.7, alpha = 0.7) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, size = 1.2, linewidth = 0.7) +
  scale_fill_manual(
    name = "Neighborhood Status",
    values = c("No Travel Time" = "#800020") # Burgundy color
  ) +
  scale_color_manual(
    name = "Legend",
    values = c("Neighborhoods" = "black", "City Boundary" = "black"),
    limits = c("Neighborhoods", "City Boundary")
  ) +
  theme_void() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Neighborhoods Without Travel Time")

# Export the plot
export_ggplot_as_png(plot_no_centroids, "Neighborhoods_Without_Travel_Time.png")







#____________ AVERAGE TRAVEL TIME AND DISTANCE _______________________________

#____________ CALCULATING AVERAGE TRAVEL AND DISTANCE FOR EACH NEIGHBORHOOD__________

# Create an empty list to store results
neighborhood_aggregates_list <- list()

# Loop through each dataset in distance_results_list
for (dataset_name in names(distance_results_list)) {
  
  # Extract the dataset
  travel_data <- distance_results_list[[dataset_name]]
  
  # Ensure both datasets contain the 'layer' column for joining
  if (!"layer" %in% colnames(travel_data) | !"layer" %in% colnames(grid_with_neighborhoods)) {
    next  # Skip if column missing
  }
  
  # Join with grid_with_neighborhoods using the layer column
  joined_data <- travel_data %>%
    left_join(grid_with_neighborhoods, by = "layer") #%>%
    #select(nearest_hospital_travel_time_min, nearest_hospital_distance_km, NOM, longitude, latitude)
    #select(nearest_hospital_travel_time_min, nearest_hospital_distance_km, NOM, geometry)
  
  #   # Join with grid_with_neighborhoods using the layer column
  # joined_data <- grid_with_neighborhoods %>%
  #   left_join(travel_data, by = "layer") #%>%
  #   #select(nearest_hospital_travel_time_min, nearest_hospital_distance_km, NOM, longitude, latitude)
  #   #select(nearest_hospital_travel_time_min, nearest_hospital_distance_km, NOM, geometry)
  # 
  
  # Aggregate travel time & distance per neighborhood
  aggregated_data <- joined_data %>%
    group_by(NOM) %>%
    summarise(
      avg_travel_time_min = mean(nearest_hospital_travel_time_min, na.rm = TRUE),
      avg_travel_distance_km = mean(nearest_hospital_distance_km, na.rm = TRUE)
      #geometry = mean(geometry, na.rm = TRUE)
      # longitude = mean(longitude, na.rm = TRUE),  # Central point for plotting
      # latitude = mean(latitude, na.rm = TRUE)    # Central point for plotting
    ) %>%
    ungroup()
  
  # Store results in list
  neighborhood_aggregates_list[[dataset_name]] <- aggregated_data
}

# Print stored dataset names
names(neighborhood_aggregates_list)

# ✅ At this point, we have 12 datasets of **average travel time & distance per neighborhood**



#_____________ Adding neighborhood GEOMETRY to the neighborhood_aggregates_list above and plotting heat map____

# Define base directory for heatmaps
base_dir <- "Neighborhood_Travel_Heatmaps_Missing_Neighborhoods"

# Ensure the directory exists
if (!dir.exists(base_dir)) {
  dir.create(base_dir)
}

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract aggregated data for the dataset
  aggregated_data <- neighborhood_aggregates_list[[dataset_name]]
  
  # Ensure it contains the 'NOM' column for joining with neighborhood geometries
  if (!"NOM" %in% colnames(aggregated_data) | !"NOM" %in% colnames(neighborhoods)) {
    next  # Skip if column missing
  }
  
  # Join aggregated data with neighborhoods SF object to retain polygon geometries
  mapped_data <- neighborhoods %>%
    left_join(aggregated_data, by = "NOM") %>%
    st_as_sf()  # Ensure it remains an SF object
  
  # Skip if no valid data
  if (nrow(mapped_data) == 0 || all(is.na(mapped_data$avg_travel_time_min))) next
  
  # Dynamic scale limits
  distance_min <- min(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  distance_max <- max(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  time_min <- min(mapped_data$avg_travel_time_min, na.rm = TRUE)
  time_max <- max(mapped_data$avg_travel_time_min, na.rm = TRUE)
  
  # Create a sub-folder for the dataset (replace spaces with underscores)
  dataset_folder <- file.path(base_dir, gsub(" ", "_", dataset_name))
  
  if (!dir.exists(dataset_folder)) {
    dir.create(dataset_folder, recursive = TRUE)
  }
  
  ## === 🔥 Heatmap for Average Travel Time per Neighborhood === ##
  travel_time_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +  # City boundary
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = c(time_min, time_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood for", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the plot in its respective folder
  travel_time_filename <- file.path(dataset_folder, paste0(dataset_name, "_travel_time.png"))
  export_ggplot_as_png(travel_time_plot, travel_time_filename)

  ## === 📏 Heatmap for Average Travel Distance per Neighborhood === ##
  travel_distance_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +  # City boundary
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = c(distance_min, distance_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood for", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the plot in its respective folder
  travel_distance_filename <- file.path(dataset_folder, paste0(dataset_name, "_travel_distance.png"))
  export_ggplot_as_png(travel_distance_plot, travel_distance_filename)
}


# ________________________ HANDLING MISSING NEIGHBORHOODS ____________________________________

# Handling the missing neighborhoods (Djambalbahr, Ambassatna, Mardjandafak)
# For those the definition of average travel time and distance are defined as:
#1- average travel time - travel time between the neighborhood centroid and the nearest hospital
#2 - average travel distance - travel distance between the neighborhood centroid and the nearest hospital



# IDENTIFICATION OF MISSING NEIGHBORHOODS

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract aggregated data for the dataset
  aggregated_data <- neighborhood_aggregates_list[[dataset_name]]
  
  # Ensure it contains the 'NOM' column for joining with neighborhood geometries
  if (!"NOM" %in% colnames(aggregated_data) | !"NOM" %in% colnames(neighborhoods)) {
    message("Skipping ", dataset_name, " - Missing 'NOM' column")
    next  # Skip if column missing
  }
  
  # Join aggregated data with neighborhoods SF object to retain polygon geometries
  mapped_data <- neighborhoods %>%
    left_join(aggregated_data, by = "NOM") %>%
    st_as_sf()  # Ensure it remains an SF object

  # Identify neighborhoods with missing travel data
  missing_neighborhoods <- mapped_data %>%
    filter(is.na(avg_travel_time_min) | is.na(avg_travel_distance_km))

  if (nrow(missing_neighborhoods) > 0) {
    message("🔍 Missing Travel Data for ", dataset_name, ":")
    print(missing_neighborhoods %>% select(NOM))  # Show only neighborhood names
  } else {
    message("✅ No missing travel data for ", dataset_name)
  }

  # Define global scale limits for consistency across all maps
  distance_scale <- c(0, 20)  # Distance in km
  time_scale <- c(0, 60)  # Travel time in minutes
  
  ## === 🔥 Heatmap for Average Travel Time per Neighborhood === ##
  travel_time_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +  # City boundary
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = time_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood for", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

 #  # Display & save the plot
 #  print(travel_time_plot)
 # export_ggplot_as_png(travel_time_plot, paste0(dataset_name, "_travel_time.png"))
  
  ## === 📏 Heatmap for Average Travel Distance per Neighborhood === ##
  travel_distance_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +  # City boundary
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = distance_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood for", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # # Display & save the plot
  # print(travel_distance_plot)
  # export_ggplot_as_png(travel_distance_plot, paste0(dataset_name, "_travel_distance.png"))
}


#________ Removing NAs for Neighborhood names from the data _________

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract dataset
  neighborhood_aggregates_list[[dataset_name]] <- neighborhood_aggregates_list[[dataset_name]] %>%
    filter(!is.na(NOM))  # Remove rows where NOM is NA
}

# Print confirmation
message("✅ Removed rows with NA values in NOM for all datasets.")
#---------------------------------------------







# CALCULATING TRAVEL TIME AND DISTANCE FOR MISSING NEIGHBORHOODS________


# Function to find the closest hospital by travel time for missing neighborhoods
find_closest_hospital_by_travel_time <- function(missing_neighborhoods, hospitals_from_moh_sf, mode) {
  
  # Extract centroids of missing neighborhoods
  neighborhood_centroids <- st_centroid(missing_neighborhoods)
  
  # Extract coordinates for OpenRouteService API
  origin_coords <- st_coordinates(neighborhood_centroids)
  destination_coords <- st_coordinates(hospitals_from_moh_sf)
  
  # Convert coordinates to proper list format
  origin_list <- split(origin_coords, seq(nrow(origin_coords))) %>% lapply(as.numeric)
  destination_list <- split(destination_coords, seq(nrow(destination_coords))) %>% lapply(as.numeric)
  
  # Compute travel time & distance matrix using OpenRouteService
  travel_matrix <- tryCatch({
    ors_matrix(
      locations = c(origin_list, destination_list),
      sources = seq(1, length(origin_list)) - 1,
      destinations = seq(length(origin_list) + 1, length(origin_list) + length(destination_list)) - 1,
      profile = mode,
      metrics = c("distance", "duration"),
      units = "km"
    )
  }, error = function(e) {
    message("ORS request failed: ", e$message)
    return(NULL)
  })
  
  # Return NULL if API request failed
  if (is.null(travel_matrix)) return(NULL)
  
  # Extract the distance and duration matrices
  distance_matrix <- travel_matrix$distances
  duration_matrix <- travel_matrix$durations
  
  # Find the nearest hospital for each missing neighborhood
  min_distance <- apply(distance_matrix, 1, min, na.rm = TRUE)
  min_duration <- apply(duration_matrix, 1, min, na.rm = TRUE)
  nearest_hospital_idx <- apply(duration_matrix, 1, which.min)
  
  # Return results as a data frame
  return(data.frame(
    NOM = missing_neighborhoods$NOM,
    avg_travel_distance_km = min_distance,
    avg_travel_time_min = min_duration / 60  # Convert seconds to minutes
  ))
}

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract mode and hospital case from dataset name
  mode <- gsub("_.*", "", dataset_name)
  hospital_case <- gsub(".*_", "", dataset_name)
  
  # Extract the current aggregated data
  aggregated_data <- neighborhood_aggregates_list[[dataset_name]]
  
  # Identify missing neighborhoods
  missing_neighborhoods <- neighborhoods %>%
    filter(!NOM %in% aggregated_data$NOM)
  
  # Skip if there are no missing neighborhoods
  if (nrow(missing_neighborhoods) == 0) next
  
  # Select hospitals based on hospital case
  selected_hospitals <- hospitals_from_moh_sf %>%
    filter(case_when(
      hospital_case == "National Hospitals Only" ~ TYPES == "National Hospital",
      hospital_case == "National and District" ~ TYPES %in% c("National Hospital", "District Hospital"),
      hospital_case == "All Hospitals" ~ TRUE
    ))
  
  # Find the closest hospital by travel time for missing neighborhoods
  closest_hospital_data <- find_closest_hospital_by_travel_time(missing_neighborhoods, selected_hospitals, mode)
  
  # Append missing neighborhood data to neighborhood_aggregates_list
  neighborhood_aggregates_list[[dataset_name]] <- bind_rows(aggregated_data, closest_hospital_data)
}

# Generate heatmaps
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Merge with neighborhood geometry
  mapped_data <- neighborhoods %>%
    left_join(neighborhood_aggregates_list[[dataset_name]], by = "NOM") %>%
    st_as_sf()
  
  # Define global scales
  distance_scale <- c(0, 20)  # Distance in km
  time_scale <- c(0, 60)  # Travel time in minutes
  
  ## Heatmap for Average Travel Time per Neighborhood
  travel_time_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = time_scale, na.value = "grey80") +
    ggtitle(paste("Avg Travel Time per Neighborhood for", dataset_name)) +
    theme_void()
  
  # # Save the travel time heatmap
  # export_ggplot_as_png(travel_time_plot, paste0(dataset_name, "_travel_time.png"))
  
  ## Heatmap for Average Travel Distance per Neighborhood
  travel_distance_plot <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = distance_scale, na.value = "grey80") +
    ggtitle(paste("Avg Travel Distance per Neighborhood for", dataset_name)) +
    theme_void()
  
  # # Save the travel distance heatmap
  # export_ggplot_as_png(travel_distance_plot, paste0(dataset_name, "_travel_distance.png"))
}



# ________________________________Adding MISSING MOTORCYCLE USE CASES ______________________

# Iterate over each dataset in neighborhood_aggregates_list
# Define correction factor for motorcycle travel time

# Update motorcycle data based on driving-car data
for (hospital_case in c("National Hospitals Only", "National and District", "All Hospitals")) {
  
  # Extract the updated car dataset
  car_data <- neighborhood_aggregates_list[[paste0("driving-car_", hospital_case)]]
  
  # If motorcycle dataset exists, update it
  if (paste0("motorcycle_", hospital_case) %in% names(neighborhood_aggregates_list)) {
    
    # Copy car data for motorcycles
    motorcycle_data <- car_data
    
    # Adjust travel time by applying the correction coefficient
    motorcycle_data$avg_travel_time_min <- car_data$avg_travel_time_min * Coefficient_Car_to_Motorcycle
    
    # Update the motorcycle dataset in the list
    neighborhood_aggregates_list[[paste0("motorcycle_", hospital_case)]] <- motorcycle_data
  }
}



#___________________________________________ PLOTTING THE HEAT MAPS _______________________________________________

# Define base directories for heatmaps
base_dir_fixed <- "Neighborhood_Heatmaps_Fixed"
base_dir_dynamic <- "Neighborhood_Heatmaps_Dynamic"

# Ensure both base directories exist
dir.create(base_dir_fixed, showWarnings = FALSE)
dir.create(base_dir_dynamic, showWarnings = FALSE)

# Define fixed scale limits
fixed_distance_scale <- c(0, 20)  # Fixed Distance in km
fixed_time_scale <- c(0, 60)  # Fixed Travel Time in minutes

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract aggregated data
  aggregated_data <- neighborhood_aggregates_list[[dataset_name]]
  
  # Ensure 'NOM' column is available for joining with neighborhood geometries
  if (!"NOM" %in% colnames(aggregated_data) | !"NOM" %in% colnames(neighborhoods)) {
    next  # Skip if missing
  }
  
  # Merge aggregated travel data with neighborhoods (SF object)
  mapped_data <- neighborhoods %>%
    left_join(aggregated_data, by = "NOM") %>%
    st_as_sf()  # Ensure it's still an SF object

  # Skip iteration if no valid data is present
  if (nrow(mapped_data) == 0 || all(is.na(mapped_data$avg_travel_time_min))) next

  # **Create subfolders for fixed and dynamic scaling**
  dataset_folder_fixed <- file.path(base_dir_fixed, gsub(" ", "_", dataset_name))
  dataset_folder_dynamic <- file.path(base_dir_dynamic, gsub(" ", "_", dataset_name))
  
  dir.create(dataset_folder_fixed, showWarnings = FALSE, recursive = TRUE)
  dir.create(dataset_folder_dynamic, showWarnings = FALSE, recursive = TRUE)

  # Create subfolders for travel time and distance within each dataset folder
  travel_time_fixed_folder <- file.path(dataset_folder_fixed, "Travel_Time_Maps")
  travel_time_dynamic_folder <- file.path(dataset_folder_dynamic, "Travel_Time_Maps")
  distance_fixed_folder <- file.path(dataset_folder_fixed, "Distance_Maps")
  distance_dynamic_folder <- file.path(dataset_folder_dynamic, "Distance_Maps")

  dir.create(travel_time_fixed_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(travel_time_dynamic_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(distance_fixed_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(distance_dynamic_folder, showWarnings = FALSE, recursive = TRUE)

  # **Dynamic Scale Limits**
  distance_min <- min(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  distance_max <- max(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  time_min <- min(mapped_data$avg_travel_time_min, na.rm = TRUE)
  time_max <- max(mapped_data$avg_travel_time_min, na.rm = TRUE)

  ## === 🔥 Heatmap for Average Travel Time per Neighborhood (Fixed & Dynamic) === ##
  travel_time_plot_fixed <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = fixed_time_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood (Fixed) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  travel_time_plot_dynamic <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = c(time_min, time_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood (Dynamic) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the travel time plots in respective folders
  export_ggplot_as_png(travel_time_plot_fixed, file.path(travel_time_fixed_folder, paste0(dataset_name, "_travel_time_fixed.png")))
  export_ggplot_as_png(travel_time_plot_dynamic, file.path(travel_time_dynamic_folder, paste0(dataset_name, "_travel_time_dynamic.png")))

  ## === 📏 Heatmap for Average Travel Distance per Neighborhood (Fixed & Dynamic) === ##
  travel_distance_plot_fixed <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = fixed_distance_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood (Fixed) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  travel_distance_plot_dynamic <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = c(distance_min, distance_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood (Dynamic) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the travel distance plots in respective folders
  export_ggplot_as_png(travel_distance_plot_fixed, file.path(distance_fixed_folder, paste0(dataset_name, "_travel_distance_fixed.png")))
  export_ggplot_as_png(travel_distance_plot_dynamic, file.path(distance_dynamic_folder, paste0(dataset_name, "_travel_distance_dynamic.png")))
}




#______________________PLOTTING THE HEAT MAPS with average travel time displayed on maps _______________________________________________



# Define base directories for static heatmaps
base_dir_fixed <- "Neighborhood_Heatmaps_Fixed"
base_dir_dynamic <- "Neighborhood_Heatmaps_Dynamic"

# Define base directory for interactive maps
base_dir_interactive <- "Neighborhood_Interactive_Maps"

# Ensure directories exist
dir.create(base_dir_fixed, showWarnings = FALSE)
dir.create(base_dir_dynamic, showWarnings = FALSE)
dir.create(base_dir_interactive, showWarnings = FALSE)

# Define fixed scale limits
fixed_distance_scale <- c(0, 20)  # Fixed Distance in km
fixed_time_scale <- c(0, 60)  # Fixed Travel Time in minutes

# Iterate over each dataset in neighborhood_aggregates_list
for (dataset_name in names(neighborhood_aggregates_list)) {
  
  # Extract aggregated data
  aggregated_data <- neighborhood_aggregates_list[[dataset_name]]
  
  # Ensure 'NOM' column is available for joining with neighborhood geometries
  if (!"NOM" %in% colnames(aggregated_data) | !"NOM" %in% colnames(neighborhoods)) {
    next  # Skip if missing
  }
  
  # Merge aggregated travel data with neighborhoods (SF object)
  mapped_data <- neighborhoods %>%
    left_join(aggregated_data, by = "NOM") %>%
    st_as_sf()  # Ensure it's still an SF object

  # Skip iteration if no valid data is present
  if (nrow(mapped_data) == 0 || all(is.na(mapped_data$avg_travel_time_min))) next

  # **Create subfolders for fixed and dynamic scaling**
  dataset_folder_fixed <- file.path(base_dir_fixed, gsub(" ", "_", dataset_name))
  dataset_folder_dynamic <- file.path(base_dir_dynamic, gsub(" ", "_", dataset_name))
  
  dir.create(dataset_folder_fixed, showWarnings = FALSE, recursive = TRUE)
  dir.create(dataset_folder_dynamic, showWarnings = FALSE, recursive = TRUE)

  # Create subfolders for travel time and distance within each dataset folder
  travel_time_fixed_folder <- file.path(dataset_folder_fixed, "Travel_Time_Maps")
  travel_time_dynamic_folder <- file.path(dataset_folder_dynamic, "Travel_Time_Maps")
  distance_fixed_folder <- file.path(dataset_folder_fixed, "Distance_Maps")
  distance_dynamic_folder <- file.path(dataset_folder_dynamic, "Distance_Maps")

  dir.create(travel_time_fixed_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(travel_time_dynamic_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(distance_fixed_folder, showWarnings = FALSE, recursive = TRUE)
  dir.create(distance_dynamic_folder, showWarnings = FALSE, recursive = TRUE)

  # **Dynamic Scale Limits**
  distance_min <- min(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  distance_max <- max(mapped_data$avg_travel_distance_km, na.rm = TRUE)
  time_min <- min(mapped_data$avg_travel_time_min, na.rm = TRUE)
  time_max <- max(mapped_data$avg_travel_time_min, na.rm = TRUE)

  ## === 🔥 Heatmap for Average Travel Time per Neighborhood (Fixed & Dynamic) === ##
  travel_time_plot_fixed <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = fixed_time_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood (Fixed) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  travel_time_plot_dynamic <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_time_min), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma", limits = c(time_min, time_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Time per Neighborhood (Dynamic) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the travel time plots in respective folders
  export_ggplot_as_png(travel_time_plot_fixed, file.path(travel_time_fixed_folder, paste0(dataset_name, "_travel_time_fixed.png")))
  export_ggplot_as_png(travel_time_plot_dynamic, file.path(travel_time_dynamic_folder, paste0(dataset_name, "_travel_time_dynamic.png")))

  ## === 📏 Heatmap for Average Travel Distance per Neighborhood (Fixed & Dynamic) === ##
  travel_distance_plot_fixed <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = fixed_distance_scale, na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood (Fixed) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  travel_distance_plot_dynamic <- ggplot() +
    geom_sf(data = mapped_data, aes(fill = avg_travel_distance_km), color = "black", linewidth = 0.2) +
    geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
    scale_fill_viridis(name = "Avg Travel Distance (km)", option = "plasma", limits = c(distance_min, distance_max), na.value = "grey80") +
    scale_color_manual(name = "Legend", values = c("City Boundary" = "black")) +
    ggtitle(paste("Avg Travel Distance per Neighborhood (Dynamic) -", dataset_name)) +
    theme_void() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  # Save the travel distance plots in respective folders
  export_ggplot_as_png(travel_distance_plot_fixed, file.path(distance_fixed_folder, paste0(dataset_name, "_travel_distance_fixed.png")))
  export_ggplot_as_png(travel_distance_plot_dynamic, file.path(distance_dynamic_folder, paste0(dataset_name, "_travel_distance_dynamic.png")))
  
  ## === 🗺️ Interactive Map for Average Travel Time per Neighborhood === ##
  # Only proceed if valid travel time data is available
  if (!all(is.na(mapped_data$avg_travel_time_min))) {
    # Transform data to WGS84 for leaflet compatibility
    mapped_data_wgs84 <- st_transform(mapped_data, crs = 4326)
    ndjamena_boundary_wgs84 <- st_transform(ndjamena_boundary, crs = 4326)
    
    # Create a color palette using the 'plasma' palette
    pal_time <- colorNumeric(palette = "plasma", domain = mapped_data_wgs84$avg_travel_time_min, na.color = "grey80")
    
    # Build the interactive leaflet map
    interactive_map <- leaflet(mapped_data_wgs84) %>%
      addProviderTiles("CartoDB.Positron") %>%
      addPolygons(
        fillColor = ~pal_time(avg_travel_time_min),
        color = "black",
        weight = 1,
        fillOpacity = 0.7,
        popup = ~paste("Neighborhood:", NOM, "<br>",
                       "Avg Travel Time:", avg_travel_time_min, "min")
      ) %>%
      addPolygons(
        data = ndjamena_boundary_wgs84,
        fill = FALSE,
        color = "black",
        weight = 2,
        group = "City Boundary"
      ) %>%
      addLegend("bottomright", 
                pal = pal_time, 
                values = mapped_data_wgs84$avg_travel_time_min,
                title = "Avg Travel Time (min)")
    
    # Create a subfolder for interactive maps for the current dataset
    dataset_folder_interactive <- file.path(base_dir_interactive, gsub(" ", "_", dataset_name))
    dir.create(dataset_folder_interactive, showWarnings = FALSE, recursive = TRUE)
    
    # Save the interactive map as an HTML file
    interactive_file <- file.path(dataset_folder_interactive, paste0(dataset_name, "_travel_time_interactive.html"))
    saveWidget(interactive_map, file = interactive_file, selfcontained = TRUE)
  }
}


# #___________________________________________________________________________
# # Rename layer to id in the fake results data set to use for joining
# grid_with_neighborhoods <- grid_with_neighborhoods %>%
#   rename(id = layer)
# 
# # Merge travel time data into neighborhood polygons
# grid_with_neighborhoods <- grid_with_neighborhoods %>%
#   left_join(fake_results, by = "id")
# 
# # Aggregate travel time per neighborhood
# neighborhood_travel_time <- grid_with_neighborhoods %>%
#   group_by(NOM) %>%  # Replace with the actual column name for neighborhood names
#   summarise(avg_travel_time = mean(travel_time, na.rm = TRUE))
# 
# # Merge travel time data into neighborhood polygons
# #rm(neighborhoods_results)
# neighborhoods_results <- st_join(neighborhoods, neighborhood_travel_time)
# 
# 
# # Remove duplicate columns (and remove the .x and .y at the end of the columns resulting from using st_join())
# 
# neighborhoods_results <- neighborhoods_results %>%
#   mutate(NOM = coalesce(NOM.x, NOM.y)) %>%  # Merge duplicate neighborhood columns
#   select(-ends_with(".x"), -ends_with(".y"))  # Remove all .x and .y columns
# 
# 
# 
# # Plotting the average time per neighborhood
# p2 <- ggplot() +
#   # Heatmap layer: Neighborhood polygons colored by average travel time
#   geom_sf(data = neighborhoods_results, aes(fill = avg_travel_time), color = "black", linewidth = 0.5) +
#   # Define color scale for travel time
#   scale_fill_viridis(name = "Avg Travel Time (min)", option = "plasma") +
#   # Add title
#   ggtitle("Average Travel Time per Neighborhood in N'Djamena") +
#   # Adjust theme
#   theme_void() +
#    theme(
#       legend.text = element_text(size = 14),
#       legend.title = element_text(size = 16, face = "bold"),
#       plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
#     )
# p2
# 
# p1+p2
# 
# 
# png("Investigating Neighborhoods with no average travel time.png", width = 5000, height = 2500, res = 300)  
# p1 + p2
# dev.off()



#_________________________________________________________________________
#                OUTPUTTING THE TRAVEL TIMES PER NEIGHBORHOOD INTO AN EXCEL
#______________________________________________________________________

library(openxlsx)

# Create the output folder if it doesn't exist
output_folder <- "Tabular Travel Times Per Neighborhood"
if (!dir.exists(output_folder)) {
  dir.create(output_folder)
}

# Create a new workbook
wb <- createWorkbook()

# Loop over each element in the neighborhood_aggregates_list and add it as a sheet
for(sheet_name in names(neighborhood_aggregates_list)) {
  # Truncate sheet name to 31 characters
  truncated_name <- substr(sheet_name, 1, 31)
  
  addWorksheet(wb, truncated_name)
  writeData(wb, sheet = truncated_name, neighborhood_aggregates_list[[sheet_name]])
}

# Define the output file path
output_file <- file.path(output_folder, "Tabular_Travel_Times_Per_Neighborhood.xlsx")

# Save the workbook
saveWorkbook(wb, file = output_file, overwrite = TRUE)







#__________________________ CUMULATIVE PLOT - PERCENT POP VS. TIME TO NEAREST HEALTH FACILITY___________



# === Ensure Required Directories Exist === #
dir.create("Cumulative_Plots", showWarnings = FALSE)
dir.create("Cumulative_Plots/Individual_Plots", showWarnings = FALSE)
dir.create("Cumulative_Plots/By_Transport_Mode", showWarnings = FALSE)
dir.create("Cumulative_Plots/By_Hospital_Case", showWarnings = FALSE)
dir.create("Cumulative_Plots/All_Combined", showWarnings = FALSE)

# === 📊 Step 1: Merge Population Data with Travel Time Data === #
combined_data_list <- list()

for (dataset_name in names(distance_results_list)) {
  
  # Extract travel time data
  travel_data <- distance_results_list[[dataset_name]]
  
  # Ensure necessary columns exist before merging
  if (!"layer" %in% colnames(travel_data) | !"layer" %in% colnames(pop_1km_df)) {
    next  # Skip if required columns are missing
  }
  
  # Merge with population data based on 'layer'
  merged_data <- left_join(travel_data, pop_1km_df, by = "layer")
  
  # Ensure valid travel time & population
  merged_data <- merged_data %>%
    filter(!is.na(nearest_hospital_travel_time_min), !is.na(population)) %>%
    arrange(nearest_hospital_travel_time_min)
  
  # Compute cumulative population percentage
  merged_data <- merged_data %>%
    mutate(cumulative_population = cumsum(population),
           cumulative_percent = (cumulative_population / sum(population)) * 100)
  
  # Store in list
  combined_data_list[[dataset_name]] <- merged_data
}

# Combine all datasets for grouped plotting
all_data_combined <- bind_rows(combined_data_list, .id = "dataset_name")

# Extract transport mode & hospital case from dataset names
all_data_combined <- all_data_combined %>%
  mutate(
    transport_mode = gsub("_.*", "", dataset_name),
    hospital_case = gsub(".*_", "", dataset_name)
  )

# === 📈 Step 2: Generate Individual Plots for Each Combination === #
for (dataset_name in names(combined_data_list)) {
  
  # Extract data
  plot_data <- combined_data_list[[dataset_name]]
  
  # Generate cumulative plot
  cumulative_plot <- ggplot(plot_data, aes(x = nearest_hospital_travel_time_min, y = cumulative_percent)) +
    geom_line(color = "blue", size = 1.2) +
    scale_x_continuous(breaks = seq(0, max(plot_data$nearest_hospital_travel_time_min, na.rm = TRUE), by = 10)) +
    scale_y_continuous(breaks = seq(0, 100, by = 5), labels = scales::percent_format(scale = 1)) +
    labs(
      title = paste("Cumulative Population Access -", dataset_name),
      x = "Travel Time to Nearest Hospital (min)",
      y = "Cumulative Population (%)"
    ) +
    theme_minimal() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )
  
  # Save the plot in the folder for individual plots
  export_ggplot_as_png(cumulative_plot, paste0("Cumulative_Plots/Individual_Plots/", dataset_name, ".png"))
}

# === 📊 Step 3: Generate Combined Plots by Transport Mode === #
for (mode in unique(all_data_combined$transport_mode)) {
  
  # Filter datasets for the transport mode
  mode_data <- all_data_combined %>%
    filter(transport_mode == mode)
  
  # Generate cumulative plot grouped by hospital case
  transport_mode_plot <- ggplot(mode_data, aes(x = nearest_hospital_travel_time_min, y = cumulative_percent, color = hospital_case)) +
    geom_line(size = 1.2) +
    scale_x_continuous(breaks = seq(0, max(mode_data$nearest_hospital_travel_time_min, na.rm = TRUE), by = 10)) +
    scale_y_continuous(breaks = seq(0, 100, by = 5), labels = scales::percent_format(scale = 1)) +
    labs(
      title = paste("Cumulative Population Access vs. Travel Time -", mode),
      x = "Travel Time to Nearest Hospital (min)",
      y = "Cumulative Population (%)",
      color = "Hospital Case"
    ) +
    theme_minimal() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    ) 

  # Save the plot
  export_ggplot_as_png(transport_mode_plot, paste0("Cumulative_Plots/By_Transport_Mode/", gsub(" ", "_", mode), ".png"))
}

# === 📊 Step 4: Generate Combined Plots by Hospital Case === #
for (case in unique(all_data_combined$hospital_case)) {
  
  # Filter datasets for the hospital case
  case_data <- all_data_combined %>%
    filter(hospital_case == case)
  
  # Generate cumulative plot grouped by transport mode
  hospital_case_plot <- ggplot(case_data, aes(x = nearest_hospital_travel_time_min, y = cumulative_percent, color = transport_mode)) +
    geom_line(size = 1.2) +
    scale_x_continuous(breaks = seq(0, max(case_data$nearest_hospital_travel_time_min, na.rm = TRUE), by = 10)) +
    scale_y_continuous(breaks = seq(0, 100, by = 5), labels = scales::percent_format(scale = 1)) +
    labs(
      title = paste("Cumulative Population Access vs. Travel Time -", case),
      x = "Travel Time to Nearest Hospital (min)",
      y = "Cumulative Population (%)",
      color = "Transport Mode"
    ) +
    theme_minimal() +
    theme(
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16, face = "bold"),
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14, face = "bold"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    ) 

  # Save the plot
  export_ggplot_as_png(hospital_case_plot, paste0("Cumulative_Plots/By_Hospital_Case/", gsub(" ", "_", case), ".png"))
}

# === 📊 Step 5: Generate Overall Combined Plot === #
combined_plot <- ggplot(all_data_combined, aes(x = nearest_hospital_travel_time_min, y = cumulative_percent, color = interaction(transport_mode, hospital_case))) +
  geom_line(size = 1) +
  scale_x_continuous(breaks = seq(0, max(all_data_combined$nearest_hospital_travel_time_min, na.rm = TRUE), by = 10)) +
  scale_y_continuous(breaks = seq(0, 100, by = 5), labels = scales::percent_format(scale = 1)) +
  labs(
    title = "Cumulative Population Access vs. Travel Time - All Cases",
    x = "Travel Time to Nearest Hospital (min)",
    y = "Cumulative Population (%)",
    color = "Transport Mode & Hospital Case"
  ) +
  theme_minimal() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )

# Save the plot
export_ggplot_as_png(combined_plot, "Cumulative_Plots/All_Combined/Overall_Combined.png")


# # Join the travel time and 1km population data frames
# # Ensure both datasets have a common grid ID for merging
# pop_travel <- fake_results %>%
#   left_join(pop_1km_df, by = c("id" = "layer")) %>%  # Merge travel time data
#   filter(!is.na(population))  # Remove any rows where population is missing
# 
# 
# # Arrange data by increasing travel time
# pop_travel <- pop_travel %>%
#   arrange(travel_time) %>%
#   mutate(
#     cumulative_population = cumsum(population) / sum(population) * 100  # Compute cumulative percentage
#   )
# 
# # Plot the cumulative curve
# ggplot(pop_travel, aes(x = travel_time, y = cumulative_population)) +
#   geom_line(color = "blue", size = 1.2) +  # Line plot
#   #geom_point(color = "red", size = 2) +  # Add points for clarity
#   labs(
#     title = "Cumulative Population with Access to Healthcare",
#     x = "Travel Time to Healthcare Facility (minutes)",
#     y = "Cumulative Percent Population (%)"
#   ) +
#   theme_minimal() +
#   theme(
#     plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
#     axis.title = element_text(size = 16),
#     axis.text = element_text(size = 14)
#   )


```


## Accessibility from City Center

``` {r}
# The goal here will here will be to evaluate travel time as we move away from the city center. Here we will make the assumption that the city center is at the Place de la Nation (Longitude: 15.039 Latitude: 12.112 N) - obtatined from Google Maps

# We will use the already calculated distance_results_list list which contains the ID and coordinates for each grid point, the average travel time (for each combination of hospital case and method of transportation)

library(sf)
library(dplyr)
library(ggplot2)
library(ggpmisc)  # For adding regression equations on plots

# Define the city center (Place de l'Indépendence) in lon/lat
center_lon <- 15.039
center_lat <- 12.112

# Create an sf object for the city center and transform to a projected CRS (UTM zone 33N, EPSG:32633)
city_center <- st_sfc(st_point(c(center_lon, center_lat)), crs = 4326)
city_center_utm <- st_transform(city_center, crs = 32633)

# Copy the list
city_center_study <- distance_results_list

# Create a parent folder for all city center study plots
parent_folder <- "City_Center_Linear"
dir.create(parent_folder, showWarnings = FALSE)

# Create subfolders under the parent folder
plots_individual_folder <- file.path(parent_folder, "Plots_Individual")
plots_grouped_by_transport_folder <- file.path(parent_folder, "Plots_Grouped_by_Transport")
plots_grouped_by_hospital_case_folder <- file.path(parent_folder, "Plots_Grouped_by_HospitalCase")
plots_all_grouped_folder <- file.path(parent_folder, "Plots_All_Grouped")

dir.create(plots_individual_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_transport_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_hospital_case_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_all_grouped_folder, showWarnings = FALSE, recursive = TRUE)

# Define the expected transport methods
transport_options <- c("driving", "cycling", "motorcycle", "foot")

# ----------------------------------------------------------------
# 1. Loop over each combination for individual plots (linear fit + equation)
# ----------------------------------------------------------------
for (i in seq_along(city_center_study)) {
  element_name <- names(city_center_study)[i]
  
  # Extract transport method by checking for known keywords (case-insensitive)
  matched_transport <- sapply(transport_options, function(x) grepl(x, element_name, ignore.case = TRUE))
  if (any(matched_transport)) {
    transport_method <- transport_options[which(matched_transport)[1]]
  } else {
    transport_method <- NA
  }
  
  # Extract hospital case from the element name.
  parts <- strsplit(element_name, "_")[[1]]
  if (tolower(parts[1]) %in% transport_options) {
    hospital_case <- ifelse(length(parts) >= 2, parts[2], NA)
  } else {
    hospital_case <- parts[1]
  }
  
  # Rename the data frame variable to 'temp_data'
  temp_data <- city_center_study[[i]]
  
  # For each grid point, create an sf point, transform to UTM, and calculate the Euclidean distance (in km)
  temp_data <- temp_data %>%
    rowwise() %>%
    mutate(
      geometry = st_sfc(st_point(c(longitude, latitude)), crs = 4326),
      geometry_utm = st_transform(geometry, crs = 32633),
      euclidean_distance = as.numeric(st_distance(geometry_utm, city_center_utm)) / 1000,
      hospital_case = hospital_case,
      transport_method = transport_method
    ) %>%
    ungroup()
  
  # Store the updated data frame back into the list
  city_center_study[[i]] <- temp_data
  
  # Create the individual plot with a linear fit and equation annotation
  p_ind <- ggplot(temp_data, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, color = "blue") +
    stat_poly_eq(
      formula = y ~ x,
      aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")),
      parse = TRUE,
      label.x.npc = "right",
      label.y.npc = 0.15,
      size = 4  # Increased font size for the equation
    ) +
    labs(title = paste("Hospital:", hospital_case, "| Method:", transport_method),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  # Save the individual plot
  export_ggplot_as_png(p_ind, file.path(plots_individual_folder, paste0(element_name, "_travel_time_vs_distance.png")))
}

# ----------------------------------------------------------------
# 2. Combine all data for grouped plotting
# ----------------------------------------------------------------
combined_df <- bind_rows(city_center_study, .id = "combination")

# ----------------------------------------------------------------
# 3. For each transport method, create one graph (color by hospital case)
# ----------------------------------------------------------------
unique_transport <- unique(combined_df$transport_method)
for (tm in unique_transport) {
  # Filter data for the current transport method
  df_tm <- combined_df %>% filter(transport_method == tm)
  
  # Create a plot with points, linear fits, and equations per hospital case
  p_group <- ggplot(df_tm, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, aes(color = hospital_case)) +
    stat_poly_eq(
      formula = y ~ x,
      aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = hospital_case),
      parse = TRUE,
      label.x.npc = "right",
      label.y.npc = "top",
      size = 4  # Increased font size for the equation
    ) +
    labs(title = paste("Transport Method:", tm, "- Travel Time vs. Distance"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  export_ggplot_as_png(p_group, file.path(plots_grouped_by_transport_folder, paste0("Travel_Time_vs_Distance_", tm, ".png")))
}

# ----------------------------------------------------------------
# 4. Create a new grouped plot by hospital case (color by transport method)
# ----------------------------------------------------------------
unique_hospital_cases <- unique(combined_df$hospital_case)
for (hc in unique_hospital_cases) {
  # Filter data for the current hospital case
  df_hc <- combined_df %>% filter(hospital_case == hc)
  
  # Create a plot with points, linear fits, and equations per transport method
  p_group_hc <- ggplot(df_hc, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = transport_method)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, aes(color = transport_method)) +
    stat_poly_eq(
      formula = y ~ x,
      aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = transport_method),
      parse = TRUE,
      label.x.npc = "right",
      label.y.npc = "top",
      size = 4  # Increased font size for the equation
    ) +
    labs(title = paste("Hospital Case:", hc, "- Travel Time vs. Distance"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  export_ggplot_as_png(p_group_hc, file.path(plots_grouped_by_hospital_case_folder, paste0("Travel_Time_vs_Distance_", hc, ".png")))
}

# ----------------------------------------------------------------
# 5. Create a combined grouped plot (faceted by transport method), color by hospital case
# ----------------------------------------------------------------
p_all <- ggplot(combined_df, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, aes(color = hospital_case)) +
  stat_poly_eq(
    formula = y ~ x,
    aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = hospital_case),
    parse = TRUE,
    label.x.npc = "right",
    label.y.npc = "top",
    size = 4  # Increased font size for the equation
  ) +
  facet_wrap(~ transport_method, scales = "free") +
  labs(title = "Travel Time vs. Distance from City Center (All Data)",
       x = "Euclidean Distance from City Center (km)",
       y = "Nearest Hospital Travel Time (min)") +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14)
  )

export_ggplot_as_png(p_all, file.path(plots_all_grouped_folder, "Travel_Time_vs_Distance_All.png"))
















# _______________________________EXPONENTIAL FIT ______________________


# Create an sf object for the city center and transform to a projected CRS (UTM zone 33N, EPSG:32633)
city_center <- st_sfc(st_point(c(center_lon, center_lat)), crs = 4326)
city_center_utm <- st_transform(city_center, crs = 32633)

# Copy the list
city_center_study <- distance_results_list

# -------------------------------
# Create a new parent folder
# -------------------------------
parent_folder <- "City_Center_Exponential"
dir.create(parent_folder, showWarnings = FALSE)

# Create subfolders under the parent folder
plots_individual_folder <- file.path(parent_folder, "Plots_Individual")
plots_grouped_by_transport_folder <- file.path(parent_folder, "Plots_Grouped_by_Transport")
plots_grouped_by_hospital_case_folder <- file.path(parent_folder, "Plots_Grouped_by_HospitalCase")
plots_all_grouped_folder <- file.path(parent_folder, "Plots_All_Grouped")

dir.create(plots_individual_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_transport_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_hospital_case_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_all_grouped_folder, showWarnings = FALSE, recursive = TRUE)

# Define the expected transport methods
transport_options <- c("driving", "cycling", "motorcycle", "foot")

# ----------------------------------------------------------------
# 1. Loop over each combination for individual plots
#    but use an exponential fit (GLM with log link)
# ----------------------------------------------------------------
for (i in seq_along(city_center_study)) {
  element_name <- names(city_center_study)[i]
  
  # Extract transport method by checking for known keywords (case-insensitive)
  matched_transport <- sapply(transport_options, function(x) grepl(x, element_name, ignore.case = TRUE))
  if (any(matched_transport)) {
    transport_method <- transport_options[which(matched_transport)[1]]
  } else {
    transport_method <- NA
  }
  
  # Extract hospital case from the element name.
  parts <- strsplit(element_name, "_")[[1]]
  if (tolower(parts[1]) %in% transport_options) {
    hospital_case <- ifelse(length(parts) >= 2, parts[2], NA)
  } else {
    hospital_case <- parts[1]
  }
  
  # Rename the data frame variable to 'temp_data'
  temp_data <- city_center_study[[i]]
  
  # For each grid point, create an sf point, transform to UTM, and calculate the Euclidean distance (in km)
  temp_data <- temp_data %>%
    rowwise() %>%
    mutate(
      geometry = st_sfc(st_point(c(longitude, latitude)), crs = 4326),
      geometry_utm = st_transform(geometry, crs = 32633),
      euclidean_distance = as.numeric(st_distance(geometry_utm, city_center_utm)) / 1000,
      hospital_case = hospital_case,
      transport_method = transport_method
    ) %>%
    ungroup()
  
  # Store the updated data frame back into the list
  city_center_study[[i]] <- temp_data
  
  # Create the individual plot with an exponential-type fit
  p_ind <- ggplot(temp_data, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min)) +
    geom_point() +
    geom_smooth(
      method = "glm",
      method.args = list(family = gaussian(link = "log")), # log link => exponential relationship
      se = FALSE,
      color = "blue"
    ) +
    labs(title = paste("Hospital:", hospital_case, "| Method:", transport_method),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  # Save the individual plot
  export_ggplot_as_png(p_ind, file.path(plots_individual_folder, paste0(element_name, "_travel_time_vs_distance.png")))
}

# ----------------------------------------------------------------
# 2. Combine all data for grouped plotting
# ----------------------------------------------------------------
combined_df <- bind_rows(city_center_study, .id = "combination")

# ----------------------------------------------------------------
# 3. For each transport method, create one graph (color by hospital case)
#    with exponential fits
# ----------------------------------------------------------------
unique_transport <- unique(combined_df$transport_method)
for (tm in unique_transport) {
  # Filter data for the current transport method
  df_tm <- combined_df %>% filter(transport_method == tm)
  
  p_group <- ggplot(df_tm, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
    geom_point() +
    geom_smooth(
      method = "glm",
      method.args = list(family = gaussian(link = "log")),
      se = FALSE,
      aes(color = hospital_case)
    ) +
    labs(title = paste("Transport Method:", tm, "- Travel Time vs. Distance (Exponential Fit)"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  export_ggplot_as_png(p_group, file.path(plots_grouped_by_transport_folder, paste0("Travel_Time_vs_Distance_", tm, ".png")))
}

# ----------------------------------------------------------------
# 4. Grouped plot by hospital case (color by transport method),
#    with exponential fits
# ----------------------------------------------------------------
unique_hospital_cases <- unique(combined_df$hospital_case)
for (hc in unique_hospital_cases) {
  df_hc <- combined_df %>% filter(hospital_case == hc)
  
  p_group_hc <- ggplot(df_hc, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = transport_method)) +
    geom_point() +
    geom_smooth(
      method = "glm",
      method.args = list(family = gaussian(link = "log")),
      se = FALSE,
      aes(color = transport_method)
    ) +
    labs(title = paste("Hospital Case:", hc, "- Travel Time vs. Distance (Exponential Fit)"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
  
  export_ggplot_as_png(p_group_hc, file.path(plots_grouped_by_hospital_case_folder, paste0("Travel_Time_vs_Distance_", hc, ".png")))
}

# ----------------------------------------------------------------
# 5. Create a combined grouped plot (faceted by transport method),
#    color by hospital case, with exponential fits
# ----------------------------------------------------------------
p_all <- ggplot(combined_df, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
  geom_point() +
  geom_smooth(
    method = "glm",
    method.args = list(family = gaussian(link = "log")),
    se = FALSE,
    aes(color = hospital_case)
  ) +
  facet_wrap(~ transport_method, scales = "free") +
  labs(title = "Travel Time vs. Distance from City Center (All Data, Exponential Fit)",
       x = "Euclidean Distance from City Center (km)",
       y = "Nearest Hospital Travel Time (min)") +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14)
  )

export_ggplot_as_png(p_all, file.path(plots_all_grouped_folder, "Travel_Time_vs_Distance_All.png"))





#___________________ POLYNOMIAL FIT _______________

# Create an sf object for the city center and transform to a projected CRS (UTM zone 33N, EPSG:32633)
city_center <- st_sfc(st_point(c(center_lon, center_lat)), crs = 4326)
city_center_utm <- st_transform(city_center, crs = 32633)

# Copy the list
city_center_study <- distance_results_list

# Create a new parent folder for polynomial fit plots
parent_folder <- "City_Center_Polynomial"
dir.create(parent_folder, showWarnings = FALSE)

# Create subfolders under the parent folder
plots_individual_folder <- file.path(parent_folder, "Plots_Individual")
plots_grouped_by_transport_folder <- file.path(parent_folder, "Plots_Grouped_by_Transport")
plots_grouped_by_hospital_case_folder <- file.path(parent_folder, "Plots_Grouped_by_HospitalCase")
plots_all_grouped_folder <- file.path(parent_folder, "Plots_All_Grouped")

dir.create(plots_individual_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_transport_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_grouped_by_hospital_case_folder, showWarnings = FALSE, recursive = TRUE)
dir.create(plots_all_grouped_folder, showWarnings = FALSE, recursive = TRUE)

# Define the expected transport methods
transport_options <- c("driving", "cycling", "motorcycle", "foot")

# ----------------------------------------------------------------
# 1. Loop over each combination for individual plots with a 2nd-order polynomial fit and equation
# ----------------------------------------------------------------
for (i in seq_along(city_center_study)) {
  element_name <- names(city_center_study)[i]
  
  # Extract transport method by checking for known keywords (case-insensitive)
  matched_transport <- sapply(transport_options, function(x) grepl(x, element_name, ignore.case = TRUE))
  if (any(matched_transport)) {
    transport_method <- transport_options[which(matched_transport)[1]]
  } else {
    transport_method <- NA
  }
  
  # Extract hospital case from the element name.
  parts <- strsplit(element_name, "_")[[1]]
  if (tolower(parts[1]) %in% transport_options) {
    hospital_case <- ifelse(length(parts) >= 2, parts[2], NA)
  } else {
    hospital_case <- parts[1]
  }
  
  # Rename the data frame variable to 'temp_data'
  temp_data <- city_center_study[[i]]
  
  # For each grid point, create an sf point, transform to UTM, and calculate the Euclidean distance (in km)
  temp_data <- temp_data %>%
    rowwise() %>%
    mutate(
      geometry = st_sfc(st_point(c(longitude, latitude)), crs = 4326),
      geometry_utm = st_transform(geometry, crs = 32633),
      euclidean_distance = as.numeric(st_distance(geometry_utm, city_center_utm)) / 1000,
      hospital_case = hospital_case,
      transport_method = transport_method
    ) %>%
    ungroup()
  
  # Store the updated data frame back into the list
  city_center_study[[i]] <- temp_data
  
  # Create the individual plot with a second-order polynomial fit
  p_ind <- ggplot(temp_data, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min)) +
    geom_point() +
    geom_smooth(method = "lm", formula = y ~ x + I(x^2), se = FALSE, color = "blue") +
    stat_poly_eq(formula = y ~ x + I(x^2),
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")),
                 parse = TRUE,
                 label.x.npc = "right",
                 label.y.npc = 0.15,
                 size = 4) +
    labs(title = paste("Hospital:", hospital_case, "| Method:", transport_method),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    theme_minimal(base_size = 14) +
    theme(plot.title = element_text(size = 18, face = "bold"),
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 14))
  
  # Save the individual plot
  export_ggplot_as_png(p_ind, file.path(plots_individual_folder, paste0(element_name, "_travel_time_vs_distance.png")))
}

# ----------------------------------------------------------------
# 2. Combine all data for grouped plotting
# ----------------------------------------------------------------
combined_df <- bind_rows(city_center_study, .id = "combination")

# ----------------------------------------------------------------
# 3. For each transport method, create one graph showing different hospital cases (color by hospital case)
# ----------------------------------------------------------------
unique_transport <- unique(combined_df$transport_method)
for (tm in unique_transport) {
  # Filter data for the current transport method
  df_tm <- combined_df %>% filter(transport_method == tm)
  
  p_group <- ggplot(df_tm, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
    geom_point() +
    geom_smooth(method = "lm", formula = y ~ x + I(x^2), se = FALSE, aes(color = hospital_case)) +
    stat_poly_eq(formula = y ~ x + I(x^2),
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = hospital_case),
                 parse = TRUE,
                 label.x.npc = "right",
                 label.y.npc = "top",
                 size = 4) +
    labs(title = paste("Transport Method:", tm, "- Travel Time vs. Distance (Polynomial Fit)"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(plot.title = element_text(size = 18, face = "bold"),
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 14))
  
  export_ggplot_as_png(p_group, file.path(plots_grouped_by_transport_folder, paste0("Travel_Time_vs_Distance_", tm, ".png")))
}

# ----------------------------------------------------------------
# 4. For each hospital case, create one graph showing different transport methods (color by transport method)
# ----------------------------------------------------------------
unique_hospital_cases <- unique(combined_df$hospital_case)
for (hc in unique_hospital_cases) {
  df_hc <- combined_df %>% filter(hospital_case == hc)
  
  p_group_hc <- ggplot(df_hc, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = transport_method)) +
    geom_point() +
    geom_smooth(method = "lm", formula = y ~ x + I(x^2), se = FALSE, aes(color = transport_method)) +
    stat_poly_eq(formula = y ~ x + I(x^2),
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = transport_method),
                 parse = TRUE,
                 label.x.npc = "right",
                 label.y.npc = "top",
                 size = 4) +
    labs(title = paste("Hospital Case:", hc, "- Travel Time vs. Distance (Polynomial Fit)"),
         x = "Euclidean Distance from City Center (km)",
         y = "Nearest Hospital Travel Time (min)") +
    scale_color_brewer(palette = "Set1") +
    theme_minimal(base_size = 14) +
    theme(plot.title = element_text(size = 18, face = "bold"),
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 14))
  
  export_ggplot_as_png(p_group_hc, file.path(plots_grouped_by_hospital_case_folder, paste0("Travel_Time_vs_Distance_", hc, ".png")))
}

# ----------------------------------------------------------------
# 5. Create a combined grouped plot faceted by transport method (color by hospital case)
# ----------------------------------------------------------------
p_all <- ggplot(combined_df, aes(x = euclidean_distance, y = nearest_hospital_travel_time_min, color = hospital_case)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2), se = FALSE, aes(color = hospital_case)) +
  stat_poly_eq(formula = y ~ x + I(x^2),
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"), group = hospital_case),
               parse = TRUE,
               label.x.npc = "right",
               label.y.npc = "top",
               size = 4) +
  facet_wrap(~ transport_method, scales = "free") +
  labs(title = "Travel Time vs. Distance from City Center (All Data, Polynomial Fit)",
       x = "Euclidean Distance from City Center (km)",
       y = "Nearest Hospital Travel Time (min)") +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(size = 18, face = "bold"),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
  
export_ggplot_as_png(p_all, file.path(plots_all_grouped_folder, "Travel_Time_vs_Distance_All.png"))






#____________________________________________________________________________________________________
# ________REPRESENTING THE CITY CENTER (PLACE DE LA NATION) WITHIN N'DJAMENA ______
#__________________________________________________________________________________________



# Convert coordinates into an sf object
place_de_la_nation <- st_as_sf(data.frame(lon = center_lon, lat = center_lat), coords = c("lon", "lat"), crs = 4326)

# Plot the neighborhoods and Place de la Nation
map_center_point <- ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, size = 0.2, alpha = 0.5) +
  geom_sf(data = place_de_la_nation, aes(color = "Place de la Nation"), size = 6, shape = 18, stroke = 2) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, size = 1.2, linewidth = 1) +
  scale_color_manual(
    name = "Legend",
    values = c("Neighborhoods" = "grey", "Place de la Nation" = "red", "City Boundary" = "black"),
    limits = c("Neighborhoods", "City Boundary", "Place de la Nation")
  ) +
  theme_void() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Place de la Nation within N'Djamena Neighborhoods")

# Export the plot
export_ggplot_as_png(map_center_point, "Place_de_la_Nation_Neighborhoods_Map.png")


#____________________________________________________________________________________
#                   PLOTTING PLADE DE LA NATION WITH NEIGHBORHOODS AND ROADS
#____________________________________________________________________________________

# Define the bounding box for N'Djamena using your city boundary
bbox <- st_bbox(ndjamena_boundary)

# Get highways (roads) from OpenStreetMap within the bounding box
roads <- opq(bbox = bbox) %>%
  add_osm_feature(key = "highway") %>%
  osmdata_sf()

# Extract the roads as sf object (lines)
roads_sf <- roads$osm_lines


# Plot the neighborhoods and Place de la Nation with roads and updated legend order
map_center_point <- ggplot() +
  geom_sf(data = neighborhoods, aes(color = "Neighborhoods"), fill = NA, size = 0.2, alpha = 0.5) +
  geom_sf(data = roads_sf, aes(color = "Roads"), size = 0.3, alpha = 0.8) +
  geom_sf(data = place_de_la_nation, aes(color = "Place de la Nation"), size = 6, shape = 18, stroke = 2) +
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, size = 1.2, linewidth = 1) +
  scale_color_manual(
    name = "Legend",
    values = c(
      "Neighborhoods" = "grey",
      "City Boundary" = "black",
      "Place de la Nation" = "red",
      "Roads" = "blue"
    ),
    limits = c("Neighborhoods", "City Boundary", "Place de la Nation", "Roads")  # Roads listed last
  ) +
  theme_void() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Place de la Nation with Roads in N'Djamena")

# Export the map
export_ggplot_as_png(map_center_point, "Place_de_la_Nation_with_Roads_Map.png", 5000)

```
# Results
## Preparing the Data

``` {r}
# Read Survey Results

survey_results <- read.xlsx('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Data/Survey/Survey Results.xlsx', sheet = 1)


# Add coordinates of the hospitals in the data


# Join hospital coordinates to survey results
# Select only relevant columns from the hospital dataset
hospitals_data <- hospitals_from_moh_sf %>%
  select(Nom, geometry) %>%  # Keep hospital name and coordinates
   mutate(
    longitude.hospital = st_coordinates(.)[, 1],
    latitude.hospital = st_coordinates(.)[, 2]
  ) %>%
  st_drop_geometry()

survey_results <- survey_results %>%
  left_join(hospitals_data, by = c("hospital.name" = "Nom")) 


# Add the centroids of the neighborhoods to survey results
neighborhood_data <- centroids %>%
  select(NOM, geometry) %>%
  mutate(
    longitude.neighborhood = st_coordinates(.)[, 1],
    latitude.neighborhood = st_coordinates(.)[, 2]
  ) %>%
  st_drop_geometry()

survey_results <- survey_results %>%
  left_join(neighborhood_data, by = c("Neighborhood" = "NOM")) 


# survey_results <- survey_results %>%
#   left_join(neighborhood_data %>% select(NOM, geometry), by = c("Neighborhood" = "NOM")) %>%
#   mutate(neighborhood.centroid = if_else(st_is_empty(neighborhood.centroid), neighborhood_data$geometry[match(Neighborhood, neighborhood_data$NOM)], neighborhood.centroid)) %>%
#   st_as_sf()

#_______________ MISSING NEIGHBORHOOD CENTROIDS __________________________

# Filter neighborhoods where neighborhood.centroid is NA
# missing_centroid_neighborhoods <- survey_results %>%
#   filter(is.na(longitude.neighborhood)) %>%
#   select(Neighborhood) %>%  # Keep only the neighborhood column
#   distinct()  # Remove duplicates
# 
# # View result
# print(missing_centroid_neighborhoods)

# Remove them
survey_results <- survey_results %>%
  filter(!is.na(longitude.neighborhood))

```


## Calculating Distances/Travel Times
### ORS API - Correlation Between Distance and Number of Visits

``` {r}




#______________ CALCULATE DISTANCES AND TRAVEL TIMES FROM NEIGHBORHOOD CENTROID TO HOSPITALS _____



#________ TRAVEL TIMES AND DISTANCE _____________
get_travel_info <- function(departure_lon, departure_lat, dest_lon, dest_lat, mode) {
  
  # ORS transportation modes mapping
  mode_map <- list(
    "car" = "driving-car",
    "motorcycle" = "driving-car",
    "bicycle" = "cycling-regular",
    "walking" = "foot-walking"
  )
  
  # Get the correct ORS mode (default to "driving-car" if not found)
  ors_mode <- mode_map[[mode]]
  if (is.null(ors_mode)) ors_mode <- "driving-car"
  
  # Call the ORS API to get route details
  result <- tryCatch({
    ors_directions(
      coordinates = list(c(departure_lon, departure_lat), c(dest_lon, dest_lat)),
      profile = ors_mode,
      output = "parsed"
    )
  }, error = function(e) {
    return(NULL)  # Return NULL if API request fails
  })
  
  if (!is.null(result)) {
    # travel_time <- result$routes[[1]]$summary$duration / 60  # Convert to minutes
    # distance <- result$routes[[1]]$summary$distance / 1000  # Convert to km
    travel_time <- result$features[[1]]$properties$summary$duration / 60  # Convert to minutes
    distance <- result$features[[1]]$properties$summary$distance / 1000  # Convert to km
    return(c(travel_time, distance))
  } else {
    return(c(NA, NA))  # Return NA if no result
  }
}


# Add travel time and distance columns
survey_results <- survey_results %>%
  rowwise() %>%
  mutate(
    travel_info = list(get_travel_info(longitude.neighborhood, latitude.neighborhood, 
                                       longitude.hospital, latitude.hospital, Method)),
    travel_time = travel_info[1],  # Extract travel time
    travel_distance = travel_info[2]  # Extract travel distance
  ) %>%
  select(-travel_info)  # Remove temporary column


#___________ INVESTIGATION _____________________________________
# All the routes leading to Toukra hospital are showing NA for travel time and distance (see block of sript below)


# Find problematic rows
problematic_rows <- survey_results %>%
  filter(is.na(travel_time) | is.na(travel_distance))
# View results
print(problematic_rows)


# Trying some points manually to see if we can find the root cause (also varying transportation method)
get_travel_info(15.12438, 12.02824, 15.1261, 12.0406, "car")

# Trying new function with "increased radius." By default, ORS searches for a road within 350m. You can increase this radius in ors_directions(). Increasing to 1km in the code below.
# The increase of the radius to 1km worked.

get_travel_info <- function(departure_lon, departure_lat, dest_lon, dest_lat, mode) {
  
  mode_map <- list(
    "car" = "driving-car",
    "motorcycle" = "driving-car",
    "bicycle" = "cycling-regular",
    "walking" = "foot-walking"
  )
  
  ors_mode <- mode_map[[mode]]
  if (is.null(ors_mode)) ors_mode <- "driving-car"

  # Increase search radius
  result <- tryCatch({
    ors_directions(
      coordinates = list(c(departure_lon, departure_lat), c(dest_lon, dest_lat)),
      profile = ors_mode,
      output = "parsed",
      radiuses = c(1000, 1000)  # Expands search radius to 1km for both points
    )
  }, error = function(e) {
    print(paste("Error:", e$message))
    return(NULL)
  })

  if (!is.null(result)) {
    if (!is.null(result$routes)) {
      travel_time <- result$features[[1]]$properties$summary$duration / 60  # Convert to minutes
      distance <- result$features[[1]]$properties$summary$distance / 1000
    } else if (!is.null(result$features)) {
      travel_time <- result$features[[1]]$properties$summary$duration / 60  # Convert to minutes
      distance <- result$features[[1]]$properties$summary$distance / 1000
    } else {
      print("ORS response did not contain valid route data.")
      return(c(NA, NA))
    }
    return(c(travel_time, distance))
  } else {
    print("ORS request failed or returned no route.")
    return(c(NA, NA))
  }
}


# Add travel time and distance columns
survey_results <- survey_results %>%
  rowwise() %>%
  mutate(
    travel_info = list(get_travel_info(longitude.neighborhood, latitude.neighborhood, 
                                       longitude.hospital, latitude.hospital, Method)),
    travel_time = travel_info[1],  # Extract travel time
    travel_distance = travel_info[2]  # Extract travel distance
  ) %>%
  select(-travel_info)  # Remove temporary column



# Calculating the distance from Toukra to the closest road and displaying it on an OpenStreetMap
# Define Toukra Hospital coordinates
hospital_coords <- data.frame(
  name = "Toukra Hospital",
  lon = 15.1261,
  lat = 12.0406
)

# Convert to sf object
hospital_sf <- st_as_sf(hospital_coords, coords = c("lon", "lat"), crs = 4326)



u <- ggplot() +
  # Roads in blue
  geom_sf(data = roads$osm_lines, aes(color = "Roads"), size = 0.3, alpha = 0.7) +
  
  # Toukra Hospital as a Bold Green Star
  geom_sf(data = hospital_sf, aes(color = "Toukra Hospital"), shape = 8, size = 6, stroke = 2, alpha = 1) +  
  # Increased size, stroke thickness, and changed to yellow for visibility
  
  # City boundary in red
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
  
  # Define color scale with custom labels
  scale_color_manual(
    name = "Legend",
    values = c("Roads" = "blue", "Toukra Hospital" = "purple", "City Boundary" = "red"),
    limits = c("City Boundary", "Roads", "Toukra Hospital")  # Custom legend order
  ) +
  
  # Add Scale Bar (Bottom Left)
  ggspatial::annotation_scale(
    location = "bl",   
    width_hint = 0.2   
  ) +
  
  # Add North Arrow (Top Left)
  ggspatial::annotation_north_arrow(
    location = "tl",  
    which_north = "true",
    pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
    style = north_arrow_fancy_orienteering  
  ) +
  
  # Slightly Zoom Out
  coord_sf(
    xlim = c(15.11, 15.15),  
    ylim = c(12.02, 12.06),  
    expand = FALSE
  ) +
  
  # Theme and title
  theme_void() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  
  ggtitle("Toukra Hospital and the Nearby Roads")

u

export_ggplot_as_png(u, "Toukra and the Nearby Roads.png")

# Create a 1 km radius buffer (in meters)
hospital_buffer <- st_buffer(st_transform(hospital_sf, crs = 3857), dist = 1000)  # Convert to meters
hospital_buffer <- st_transform(hospital_buffer, crs = 4326)  # Convert back to lat/lon

x <- ggplot() +
  # Roads in blue
  geom_sf(data = roads$osm_lines, aes(color = "Roads"), size = 0.3, alpha = 0.7) +
  
  # 1 km Radius Circle Around Toukra Hospital (Pink Dashed Line) - Now in Legend
  geom_sf(data = hospital_buffer, aes(color = "1km Radius"), fill = NA, linewidth = 1, linetype = "dashed") +
  
  # Toukra Hospital as a Bold Purple Star (Now in Legend)
  geom_sf(data = hospital_sf, aes(color = "Toukra Hospital"), shape = 8, size = 6, stroke = 2, alpha = 1) +  
  
  # City boundary in red (linewidth = 1 as per your default style)
  geom_sf(data = ndjamena_boundary, aes(color = "City Boundary"), fill = NA, linewidth = 1) +
  
  # Define color scale with custom labels (Include "1km Radius")
  scale_color_manual(
    name = "Legend",
    values = c("Roads" = "blue", "1km Radius" = "pink", "Toukra Hospital" = "purple", "City Boundary" = "red"),
    limits = c("City Boundary", "Roads", "Toukra Hospital", "1km Radius")  # Custom legend order
  ) +
  
  # # Define shape scale (Ensures the star appears in the legend)
  # scale_shape_manual(
  #   name = "Legend",
  #   values = c("Toukra Hospital" = 8)  # Shape 8 = Star
  # ) +
  # 
  # # Define linetype scale for dashed lines in legend
  # scale_linetype_manual(
  #   name = "Legend",
  #   values = c("1km Radius" = "dashed"),
  #   guide = guide_legend(override.aes = list(color = "pink", linewidth = 1))  # Ensure legend shows as a line
  # ) +
  
  # Add Scale Bar (Bottom Left)
  ggspatial::annotation_scale(
    location = "bl",   
    width_hint = 0.2   
  ) +
  
  # Add North Arrow (Top Left)
  ggspatial::annotation_north_arrow(
    location = "tl",  
    which_north = "true",
    pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
    style = north_arrow_fancy_orienteering  
  ) +
  
  # Slightly Zoom Out
  coord_sf(
    xlim = c(15.11, 15.15),  
    ylim = c(12.02, 12.06),  
    expand = FALSE
  ) +
  
  # Theme and title
  theme_void() +
  theme(
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  ) +
  
  ggtitle("Toukra Hospital and the Nearby Roads")
x
export_ggplot_as_png(x, "Toukra Hospital and the Nearby Roads with 1km Radius.png")



# ______________ CORRELATION BETWEEN DISTANCE AND NUMBER OF VISITS ___________________________

# Exporting the survey results data
write_csv(survey_results, "survey_results.csv")

# Scatter plot: Travel Time vs Delta_4Visit_Model
ggplot(survey_results, aes(x = travel_time, y = Delta_4Visit_Model, color = Number.of.Weeks.Pregnant)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +  # Add trend line
  scale_color_viridis_c(name = "Weeks Pregnant") +  
  labs(title = "Travel Time vs Delta_4Visit_Model",
       x = "Travel Time (minutes)", y = "Delta 4-Visit Model") +
  theme_minimal()

# Scatter plot: Travel Distance vs Delta_4Visit_Model
ggplot(survey_results, aes(x = travel_distance, y = Delta_4Visit_Model, color = Number.of.Weeks.Pregnant)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_color_viridis_c(name = "Weeks Pregnant") +  
  labs(title = "Travel Distance vs Delta_4Visit_Model",
       x = "Travel Distance (km)", y = "Delta 4-Visit Model") +
  theme_minimal()

# Box plot: Travel Time Grouped by Delta_4Visit_Model
ggplot(survey_results, aes(x = as.factor(Delta_4Visit_Model), y = travel_time)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  labs(title = "Travel Time Distribution by Delta_4Visit_Model",
       x = "Delta 4-Visit Model", y = "Travel Time (minutes)") +
  theme_minimal()

# Box plot: Travel Distance Grouped by Delta_4Visit_Model
ggplot(survey_results, aes(x = as.factor(Delta_4Visit_Model), y = travel_distance)) +
  geom_boxplot(fill = "lightgreen", alpha = 0.7) +
  labs(title = "Travel Distance Distribution by Delta_4Visit_Model",
       x = "Delta 4-Visit Model", y = "Travel Distance (km)") +
  theme_minimal()

# Heatmap: Travel Time vs Delta_4Visit_Model (Binned)
ggplot(survey_results, aes(x = travel_time, y = Delta_4Visit_Model)) +
  geom_bin2d(bins = 20) +
  scale_fill_viridis_c(name = "Count") +
  labs(title = "Heatmap of Travel Time vs Delta_4Visit_Model",
       x = "Travel Time (minutes)", y = "Delta 4-Visit Model") +
  theme_minimal()


```



### Google Maps API - Correlation Between Distance and Number of Visits
``` {r}

#________________________________CREATING THE FUNCTION ___________________________________
# library(httr)
# library(jsonlite)

# Google API Key (Replace with your actual API key)
google_api_key <- ""


library(httr2)

get_google_travel_info_httr2 <- function(departure_lon, departure_lat, dest_lon, dest_lat, method) {
  
  # Map transportation methods
  mode_map <- list(
    "car" = "driving",
    "motorcycle" = "driving",
    "bicycle" = "bicycling",
    "walking" = "walking"
  )
  
  # Use correct mode or default to "driving"
  mode <- mode_map[[method]]
  if (is.null(mode)) mode <- "driving"
  
  # Set departure time to 11 AM (peak traffic)
  departure_time <- as.integer(as.POSIXct(Sys.Date(), tz = "UTC")) + (11 * 3600)

  # Construct API request
  url <- paste0("https://maps.googleapis.com/maps/api/distancematrix/json?",
                "origins=", departure_lat, ",", departure_lon,
                "&destinations=", dest_lat, ",", dest_lon,
                "&mode=", mode,
                "&departure_time=", departure_time, 
                "&key=", google_api_key)

  # Send API request with httr2
  response <- request(url) |> req_perform()
  
  # Parse JSON response
  data <- response |> resp_body_json()

  # Extract travel time & distance
  if (data$status == "OK" && data$rows[[1]]$elements[[1]]$status == "OK") {
    travel_time <- data$rows[[1]]$elements[[1]]$duration_in_traffic$value / 60  # Convert to minutes
    distance <- data$rows[[1]]$elements[[1]]$distance$value / 1000  # Convert to km
    return(c(travel_time, distance))
  } else {
    return(c(NA, NA))  # Return NA if request fails
  }
}




get_google_travel_info_httr2 <- function(departure_lon, departure_lat, dest_lon, dest_lat, method) {
  
  # Map transportation methods to Google API modes
  mode_map <- list(
    "car" = "driving",
    "motorcycle" = "driving",
    "bicycle" = "bicycling",
    "walking" = "walking"
  )
  
  # Use correct mode or default to "driving"
  mode <- mode_map[[method]]
  if (is.null(mode)) mode <- "driving"
  
  # Set departure time to 11 AM (peak traffic)
  departure_time <- as.integer(as.POSIXct(Sys.Date(), tz = "UTC")) + (11 * 3600)

  # Construct API request
  url <- paste0("https://maps.googleapis.com/maps/api/distancematrix/json?",
                "origins=", departure_lat, ",", departure_lon,
                "&destinations=", dest_lat, ",", dest_lon,
                "&mode=", mode,
                "&departure_time=", departure_time, 
                "&key=", google_api_key)

  # Send API request with httr2
  response <- request(url) |> req_perform()
  
  # Parse JSON response
  data <- response |> resp_body_json()
  
  # Print full API response for debugging
  print(data)

  # Extract travel time & distance
  if (data$status == "OK" && data$rows[[1]]$elements[[1]]$status == "OK") {
    travel_time <- data$rows[[1]]$elements[[1]]$duration_in_traffic$value / 60  # Convert to minutes
    distance <- data$rows[[1]]$elements[[1]]$distance$value / 1000  # Convert to km
    return(c(travel_time, distance))
  } else {
    print("API request failed or returned no route.")  # Debugging message
    return(c(NA, NA))  # Return NA if request fails
  }
}


library(lubridate)  # For timezone conversion



# Function to get travel time & distance at 11 AM N'Djamena time
get_google_travel_info_httr2 <- function(departure_lon, departure_lat, dest_lon, dest_lat, method) {
  
  # Map transportation methods to Google API modes
  mode_map <- list(
    "car" = "driving",
    "motorcycle" = "driving",
    "bicycle" = "bicycling",
    "walking" = "walking"
  )
  
  # Use correct mode or default to "driving"
  mode <- mode_map[[method]]
  if (is.null(mode)) mode <- "driving"

  # ✅ Ensure departure_time is set to 11 AM in N'Djamena time
  current_time <- Sys.time()  # Get current system time
  today_11am_ndjamena <- as.POSIXct(paste(Sys.Date(), "11:00:00"), tz = "Africa/Ndjamena")  # 11 AM today in N'Djamena

  # If current time is past 11 AM in N'Djamena, set it to tomorrow's 11 AM
  if (current_time >= today_11am_ndjamena) {
    departure_time <- as.integer(as.POSIXct(today_11am_ndjamena + (24 * 3600)))  # Move to tomorrow's 11 AM
  } else {
    departure_time <- as.integer(as.POSIXct(today_11am_ndjamena))  # Use today's 11 AM
  }

  # Construct API request
  url <- paste0("https://maps.googleapis.com/maps/api/distancematrix/json?",
                "origins=", departure_lat, ",", departure_lon,
                "&destinations=", dest_lat, ",", dest_lon,
                "&mode=", mode,
                "&departure_time=", departure_time, 
                "&key=", google_api_key)

  # Send API request with httr2
  response <- request(url) |> req_perform()
  
  # Parse JSON response
  data <- response |> resp_body_json()
  
  # Print full API response for debugging
  print(data)

  # Extract travel time & distance
  if (data$status == "OK" && data$rows[[1]]$elements[[1]]$status == "OK") {
    travel_time <- data$rows[[1]]$elements[[1]]$duration_in_traffic$value / 60  # Convert to minutes
    distance <- data$rows[[1]]$elements[[1]]$distance$value / 1000  # Convert to km
    return(c(travel_time, distance))
  } else {
    print("API request failed or returned no route.")  # Debugging message
    return(c(NA, NA))  # Return NA if request fails
  }
}
# Trying one manual point
#get_travel_info(15.12438, 12.02824, 15.1261, 12.0406, "car")



#get_google_travel_info_httr2(15.12438, 12.02824, 15.1261, 12.0406, "car")




#_____________________ APPLYING THE FUNCTION TO THE SURVEY RESULTS _________________________

survey_results <- survey_results %>%
  rowwise() %>%
  mutate(
    google_travel_info = list(get_google_travel_info_httr2(
      longitude.neighborhood, latitude.neighborhood, 
      longitude.hospital, latitude.hospital, Method
    )),
    google_travel_time = ifelse(
      Method == "motorcycle", 
      google_travel_info[1] * Coefficient_Car_to_Motorcycle,  # Apply 0.85 coefficient for motorcycle
      google_travel_info[1]          # Use raw time for other methods
    ),
    google_travel_distance = google_travel_info[2]  # Distance stays the same
  ) %>%
  select(-google_travel_info)  # Remove temporary list column

# View updated dataset
head(survey_results)

# Export the survey results data
write_csv(survey_results, "survey_results_google_maps_api.csv")


```
## General Insights

``` {r}





# ________________________________ AVERAGE TRAVEL RADIUS AND DEPARTING NEIGHBORHOODS ____________
# Extract the unique hospital names
hospital_list <- unique(survey_results$hospital.name)

# Create an empty list to store plots
hospital_plots <- list()

# Loop over each hospital to generate its respective plot
for (selected_hospital in hospital_list) {
  
  # ✅ Ensure hospital name is available
  print(paste("Processing:", selected_hospital))

  # ✅ Join neighborhoods with patients who departed from them
  neighborhoods_with_hospital <- neighborhoods %>%
    left_join(survey_results %>% select(hospital.name, Neighborhood) %>% distinct(), 
              by = c("NOM" = "Neighborhood"))

  # ✅ Filter only neighborhoods relevant to the selected hospital
  neighborhoods_shaded <- neighborhoods_with_hospital %>%
    filter(hospital.name == selected_hospital)

  # ✅ Ensure `hospital.name` is included when creating `hospitals_sf`
  hospitals_sf <- survey_results %>%
    filter(hospital.name == selected_hospital) %>%
    select(hospital.name, longitude.hospital, latitude.hospital) %>%
    distinct() %>%
    drop_na(longitude.hospital, latitude.hospital) %>%
    st_as_sf(coords = c("longitude.hospital", "latitude.hospital"), crs = 4326) %>%
    mutate(hospital.name = selected_hospital)

  # ✅ Compute the average travel radius
  average_radius <- survey_results %>%
    filter(hospital.name == selected_hospital) %>%
    group_by(hospital.name) %>%
    summarise(avg_distance = mean(google_travel_distance, na.rm = TRUE)) %>%
    ungroup()

  # ✅ Ensure `hospital.name` exists before joining
  if (!"hospital.name" %in% colnames(hospitals_sf)) {
    hospitals_sf <- hospitals_sf %>%
      mutate(hospital.name = selected_hospital)
  }

  if (!"hospital.name" %in% colnames(average_radius)) {
    average_radius <- average_radius %>%
      mutate(hospital.name = selected_hospital)
  }

  # ✅ Join `average_radius` with `hospitals_sf`
  hospitals_sf <- hospitals_sf %>%
    left_join(average_radius, by = "hospital.name")

  # ✅ Ensure avg_distance is present (fix error)
  if (!"avg_distance" %in% colnames(hospitals_sf)) {
    hospitals_sf <- hospitals_sf %>%
      mutate(avg_distance = NA)  # Set NA if missing
  }

  # ✅ Create a **darker shaded circle** around the hospital to represent the **average travel radius**
  hospital_buffer <- st_buffer(hospitals_sf, dist = hospitals_sf$avg_distance * 1000)  # Convert km to meters

  # ✅ Create a **dashed red outer perimeter** for the travel radius
  hospital_circle <- st_cast(st_boundary(hospital_buffer), "MULTILINESTRING")  # Ensure it's a line

  # ✅ Extract coordinates for text annotation (bottom right placement)
  hospitals_sf_coords <- hospitals_sf %>%
    mutate(longitude = st_coordinates(.)[, 1],
           latitude = st_coordinates(.)[, 2]) %>%
    mutate(avg_radius_label = ifelse(is.na(avg_distance), "Avg Radius: N/A", 
                                     paste0("Avg Radius: ", round(avg_distance, 1), " km")))

  # ✅ Format the average radius text for the legend
  avg_radius_text <- ifelse(is.na(hospitals_sf$avg_distance[1]), 
                            "Average Travel Radius (N/A)", 
                            paste0("Average Travel Radius (", round(hospitals_sf$avg_distance[1], 1), " km)"))

  # Generate the plot for the selected hospital
  hospital_plot <- ggplot() +
    # Plot city boundary
    geom_sf(data = ndjamena_boundary, fill = NA, color = "black", linewidth = 1) +
    
    # ✅ Plot all neighborhoods as outlines (no fill)
    geom_sf(data = neighborhoods, fill = NA, color = "black", linewidth = 0.5) +
    
    # ✅ Color departing neighborhoods in burgundy
    geom_sf(data = neighborhoods_shaded, aes(fill = "Departing Neighborhoods"), alpha = 0.6, color = "black", linewidth = 0.3) +
    
    # ✅ Add a **darker shaded circle** around the hospital to represent the **average travel radius**
    geom_sf(data = hospital_buffer, aes(fill = avg_radius_text), alpha = 0.5, color = NA) +  # Increased alpha for more shading
    
    # ✅ Add a **dashed red outline** for the travel radius perimeter
    geom_sf(data = hospital_circle, aes(linetype = avg_radius_text), color = "red", linewidth = 1) +
    
    # # ✅ Move the average travel radius text to the bottom right
    # geom_text(data = hospitals_sf_coords, aes(x = longitude + 0.02, y = latitude - 0.03, label = avg_radius_label),
    #           size = 5, color = "black", fontface = "bold") +
     # ✅ Move the average travel radius text to the bottom right
    geom_text(data = hospitals_sf_coords, aes(x = longitude - 0.08, y = latitude - 0.04, label = avg_radius_label),
              size = 5, color = "black") +
    
    # ✅ Make the hospital star red and specify it in the legend
    geom_sf(data = hospitals_sf, aes(shape = "Hospital"), size = 4, stroke = 1.5, color = "red") +
    
    # ✅ Add a scale bar at the bottom left
    ggspatial::annotation_scale(
      location = "bl", width_hint = 0.2, text_cex = 1
    ) +
    
    # ✅ Add a North arrow at the top left
    ggspatial::annotation_north_arrow(
      location = "tl", which_north = "true",
      pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
      style = north_arrow_fancy_orienteering
    ) +
    
    # ✅ Define a clean and structured legend
    scale_fill_manual(
      name = "",
      values = c(
        "Departing Neighborhoods" = "#800020",  # Burgundy
        avg_radius_text = "purple"  # Darker shading for travel radius
      )
    ) +
    
    scale_color_manual(
      name = "Legend",
      values = c(
        avg_radius_text = "red"  # Red for travel radius outline
      )
    ) +
    
    scale_shape_manual(
      name = "Legend",
      values = c("Hospital" = 8)  # Star symbol for hospital
    ) +
    
    scale_linetype_manual(
      name = "Legend",
      values = c(avg_radius_text = "dashed")  # Dashed line for travel radius
    ) +
    
    # Title and theme
    ggtitle(paste(selected_hospital, " - Departing Neighborhoods and Average Travel Radius")) +
    theme_void() +  # ✅ Use a clean void theme
    theme(
      legend.text = element_text(size = 12),
      legend.title = element_text(size = 14, face = "bold"),
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
    )

  # Store the plot in a list
  hospital_plots[[selected_hospital]] <- hospital_plot
}

# Display all hospital plots (they will be printed sequentially)
for (plot_name in names(hospital_plots)) {
  plot_object <- hospital_plots[[plot_name]]  # Retrieve the actual ggplot object
  print(plot_object)  # Display plot (optional)
  
  # Call the export function with the plot object and formatted filename
  export_ggplot_as_png(plot_object, paste0(plot_name, ".png"))  
}






#________ GENERAL INSIGHTS ABOUT PATIENTS ___________




# Load the survey data
df <- read_excel('/Users/kabbod/Library/CloudStorage/OneDrive-Personal/School/MIT/Classes/Thesis/R Code/Data/Survey/Survey Results.xlsx')

# Create output directory
output_dir <- "General Insights"
if (!dir.exists(output_dir)) dir.create(output_dir)

# Define a custom theme for publication-quality plots
theme_thesis <- theme_minimal() +
  theme(
    text = element_text(size = 14),
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  )

## 1️⃣ Hospital Type Distribution
plot1 <- ggplot(df, aes(y = `Hospital Type`)) +
  geom_bar(fill = "#0073C2FF") +
  labs(title = "Distribution of Hospital Types", x = "Count", y = "Hospital Type") +
  theme_thesis
export_ggplot_as_png(plot1, file.path(output_dir, "hospital_type_distribution.png"))

## 2️⃣ Age Distribution
plot2 <- ggplot(df, aes(x = Age)) +
  geom_histogram(bins = 10, fill = "#0073C2FF", color = "black") +
  labs(title = "Age Distribution of Respondents", x = "Age", y = "Count") +
  theme_thesis
export_ggplot_as_png(plot2, file.path(output_dir, "age_distribution.png"))



# Calculate the minimum and maximum age (using Age column)
min_age <- floor(min(df$Age, na.rm = TRUE))
max_age <- ceiling(max(df$Age, na.rm = TRUE)) +5

# Generate the age distribution plot using binwidth with a boundary set at min_age
plot2 <- ggplot(df, aes(x = Age)) +
  geom_histogram(binwidth = 5, fill = "#0073C2FF", color = "black", boundary = min_age) +
  labs(title = "Age Distribution of Respondents", x = "Age", y = "Count") +
  theme_thesis +
  scale_x_continuous(breaks = seq(min_age, max_age, by = 5))

# Display the plot
print(plot2)

# Save the plot using your export function
export_ggplot_as_png(plot2, file.path("General Insights", "age_distribution.png"))


## 3️⃣ Education Level Distribution
plot3 <- ggplot(df, aes(y = `Highest Level of Education`)) +
  geom_bar(fill = "#E69F00") +
  labs(title = "Distribution of Education Levels", x = "Count", y = "Education Level") +
  theme_thesis
export_ggplot_as_png(plot3, file.path(output_dir, "education_level_distribution.png"))

## 4️⃣ Neighborhood Representation
total_neighborhoods <- 87
num_neighborhoods <- length(unique(df$Neighborhood))

neighborhood_data <- data.frame(
  category = c("Represented", "Not Represented"),
  count = c(num_neighborhoods, total_neighborhoods - num_neighborhoods)
)

plot4 <- ggplot(neighborhood_data, aes(x = "", y = count, fill = category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  scale_fill_manual(values = c("Represented" = "#56B4E9", "Not Represented" = "#E69F00")) +
  labs(title = "Neighborhood Representation in Survey") +
  theme_void() +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  )
export_ggplot_as_png(plot4, file.path(output_dir, "neighborhood_representation.png"))



# Filter out respondents who answered "Yes" for attending the closest facility,
# then count the top 10 reasons from "Reason Category"
reason_counts <- df %>%
  filter(`Is this the closest healthcare facility to your home with prenatal care?` == "No") %>%
  count(`Reason Category`, name = "n") %>%
  top_n(10, wt = n)

plot6 <- ggplot(reason_counts, aes(y = reorder(`Reason Category`, n), x = n)) +
  geom_bar(stat = "identity", fill = "#D55E00") +
  labs(title = "Top Reasons for Not Attending the Closest Facility",
       x = "Count", y = "Reason") +
  theme_thesis +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

export_ggplot_as_png(plot6, file.path(output_dir, "reasons_not_attending_closest.png"))



# Count responses by Reason Category (Column T)
reason_data <- df %>%
  filter(!is.na(`Reason Category`)) %>%
  count(`Reason Category`, name = "count") %>%
  arrange(desc(count)) %>%
  mutate(
    percent = round(100 * count / sum(count), 1),
    label = paste0(`Reason Category`, " (", percent, "%, n=", count, ")")
  )

# Create the General Insights folder if it doesn't exist
if (!dir.exists("General Insights")) {
  dir.create("General Insights")
}

# Generate the pie chart using ColorBrewer "Set2" palette
reason_pie <- ggplot(reason_data, aes(x = "", y = count, fill = `Reason Category`)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y") +
  theme_void() +
  labs(title = "Reasons for Not Attending the Closest Facility") +
  geom_text(aes(label = paste0(percent, "%, n=", count)),
            position = position_stack(vjust = 0.5), 
            size = 5) +
  scale_fill_brewer(palette = "Set2") +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_blank()
  )

# Display the plot
print(reason_pie)

# Save the plot in the General Insights folder using export_ggplot_as_png
export_ggplot_as_png(reason_pie, "General Insights/PieChart_Reason_Category.png")



# Generate a stacked bar chart:
# X-axis: DetailedTransport; bars are filled by MainTransport
transport_plot <- ggplot(df_transport, aes(x = DetailedTransport, fill = MainTransport)) +
  geom_bar() +
  labs(title = "Stacked Bar Chart: Detailed Methods Colored by Primary Mode",
       x = "Detailed Transportation Method",
       y = "Number of Respondents",
       fill = "Primary Transportation Method") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Display the plot
print(transport_plot)

# Save the plot using your export function
export_ggplot_as_png(transport_plot, "General Insights/Stacked_Transport_Details.png")













# Rename columns for clarity:
# Column M: "Means of Transportation Used for Visit" → MainTransport (Primary)
# Column L: "Method" → DetailedTransport (Detailed)
df <- df %>%
  rename(MainTransport = `Means of Transportation Used for Visit`,
         DetailedTransport = Method)

# Filter out rows with missing values in the two key columns
df_transport <- df %>% 
  filter(!is.na(MainTransport) & !is.na(DetailedTransport))

# Define a custom theme for thesis-quality plots
theme_thesis <- theme_minimal(base_size = 14) +
  theme(
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  )

## 1. Stacked Bar Chart:
# X-axis: DetailedTransport; bars are filled by MainTransport
stacked_bar <- ggplot(df_transport, aes(x = DetailedTransport, fill = MainTransport)) +
  geom_bar() +
  labs(title = "a) Primary Transportation Method",
       x = "Primary Transportation Method",
       y = "Number of Respondents",
       fill = "Detailed Method") +
  theme_thesis +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

## 2. Pie Chart for Detailed Transportation Methods:
# Calculate counts for each detailed transportation method (DetailedTransport)
detailed_mode_counts <- df_transport %>% count(DetailedTransport)

# Generate a pie chart showing the distribution of detailed transportation methods
detailed_pie <- ggplot(detailed_mode_counts, aes(x = "", y = n, fill = DetailedTransport)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  labs(title = "b) Distribution of Primary Transportation Method", fill = "Legend") +
  theme_void(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  ) +
  geom_text(aes(label = percent(n / sum(n), accuracy = 1)),
            position = position_stack(vjust = 0.5), size = 5)

## Combine the two plots side by side using patchwork
combined_plot <- stacked_bar + detailed_pie + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot)

# Save the combined plot using your export function into the General Insights folder
export_ggplot_as_png(combined_plot, "General Insights/Transportation_Methods_Combined.png")






theme(aspect.ratio = 1)

transport_pie <- ggplot(transport_counts, aes(x = "", y = n, fill = MainTransport)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  labs(title = "Primary Transportation Methods per Hospital", fill = "Method") +
  theme_void(base_size = 14) +
  theme(
    aspect.ratio = 1,  # Ensures the panels are square (full circles)
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  ) +
  geom_text(aes(label = scales::percent(perc, accuracy = 1)),
            position = position_stack(vjust = 0.5), size = 5) +
  facet_wrap(~ `Hospital Name`)

print(transport_pie)


#___________ REPRESENTED NEIGHBORHOODS -______


# Summarize survey data by neighborhood (e.g., count the number of responses per neighborhood)
survey_summary <- df %>%
  filter(!is.na(Neighborhood)) %>%
  group_by(Neighborhood) %>%
  summarise(response_count = n())

# Join the survey summary to the neighborhoods sf object.
mapped_data <- neighborhoods %>%
  left_join(survey_summary, by = c("NOM" = "Neighborhood"))

# Create a new variable "represented" to indicate if a neighborhood was represented in the survey.
mapped_data <- mapped_data %>%
  mutate(represented = ifelse(is.na(response_count) | response_count == 0,
                              "Not Represented", "Represented"))

# Force the factor levels to ensure proper mapping
mapped_data$represented <- factor(mapped_data$represented, levels = c("Represented", "Not Represented"))

# Create the map
representation_map <- ggplot() +
  # Plot city boundary for context
  geom_sf(data = ndjamena_boundary, fill = NA, color = "black", linewidth = 1) +
  # Plot all neighborhoods as outlines
  geom_sf(data = neighborhoods, fill = NA, color = "black", linewidth = 0.5) +
  # Fill neighborhoods that are represented with burgundy
  geom_sf(data = mapped_data, aes(fill = represented), color = "black", alpha = 0.6, linewidth = 0.3) +
  scale_fill_manual(
    name = "Legend",
    values = c("Represented" = "#800020", "Not Represented" = "white")
  ) +
  ggtitle("Neighborhood Representation Based on Survey Data") +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  # Add a scale bar and north arrow for context
  ggspatial::annotation_scale(location = "bl", width_hint = 0.2, text_cex = 1) +
  ggspatial::annotation_north_arrow(location = "tl", which_north = "true",
                                     pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
                                     style = north_arrow_fancy_orienteering)

# Display the map
print(representation_map)

# Save the map using your custom export function
export_ggplot_as_png(representation_map, "General Insights/Neighborhood_Representation.png")



#________ REPRESENTED NEIGHBORHOODS WITH SCALE _________


# Summarize survey data by neighborhood (count responses per neighborhood)
survey_summary <- df %>%
  filter(!is.na(Neighborhood)) %>%
  group_by(Neighborhood) %>%
  summarise(response_count = n())

# Join the survey summary to the neighborhoods sf object.
mapped_data <- neighborhoods %>%
  left_join(survey_summary, by = c("NOM" = "Neighborhood"))

# Replace NA in response_count with 0 (for neighborhoods with no responses)
mapped_data$response_count[is.na(mapped_data$response_count)] <- 0

# Create the map with response_count-based fill and labels for neighborhoods with > 0 responses
representation_map <- ggplot() +
  # Plot city boundary for context
  geom_sf(data = ndjamena_boundary, fill = NA, color = "black", linewidth = 1) +
  # Plot all neighborhoods as outlines for context
  geom_sf(data = neighborhoods, fill = NA, color = "black", linewidth = 0.5) +
  # Fill neighborhoods based on number of responses
  geom_sf(data = mapped_data, aes(fill = response_count), color = "black", alpha = 0.6, linewidth = 0.3) +
  # Add labels only for neighborhoods with > 0 responses
  geom_sf_text(data = subset(mapped_data, response_count > 0),
               aes(label = response_count), size = 4, color = "black", fontface = "bold") +
  # Use a continuous fill gradient from white (low count) to burgundy (high count)
  scale_fill_gradientn(
    colors = c("white", "#FFCCCC", "#FF6666", "#800020"),
    name = "Response Count",
    na.value = "white"
  ) +
  ggtitle("Neighborhood Representation Based on Survey Data") +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  # Add a scale bar and north arrow for context
  ggspatial::annotation_scale(location = "bl", width_hint = 0.2, text_cex = 1) +
  ggspatial::annotation_north_arrow(
    location = "tl", which_north = "true",
    pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
    style = north_arrow_fancy_orienteering
  )

# Display the map
print(representation_map)

# Save the map using your custom export function
export_ggplot_as_png(representation_map, "General Insights/Neighborhood_Representation_ResponseCount.png")





## 5. Stacked Bar Chart for Transportation Methods
# Using column "Means of Transportation Used for Visit" for primary and "Method" for detailed
df <- df %>%
  rename(MainTransport = `Means of Transportation Used for Visit`,
         DetailedTransport = Method)

df_transport <- df %>% filter(!is.na(MainTransport) & !is.na(DetailedTransport))

transport_stacked <- ggplot(df_transport, aes(x = MainTransport, fill = DetailedTransport)) +
  geom_bar() +
  labs(title = "Method of Transportation of Patients",
       x = "Method of Transportation",
       y = "Number of Respondents",
       fill = "Detailed Method") +
  theme_thesis +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
export_ggplot_as_png(transport_stacked, "General Insights/Stacked_Transportation_Methods.png")

### 6. Pie Chart for Primary Transportation Methods
primary_transport_counts <- df_transport %>% count(MainTransport)
transport_pie <- ggplot(primary_transport_counts, aes(x = "", y = n, fill = MainTransport)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  labs(title = "Distribution of Primary Transportation Methods", fill = "Method") +
  theme_void(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold")
  ) +
  geom_text(aes(label = paste0(percent(n/sum(n), accuracy = 1), "\n(n=", n, ")")),
            position = position_stack(vjust = 0.5), size = 5)
export_ggplot_as_png(transport_pie, "General Insights/Primary_Transportation_Pie.png")








# Split the data by hospital:
plot_list <- lapply(
  split(transport_counts, transport_counts$`Hospital Name`),
  function(d) {
    ggplot(d, aes(x = "", y = n, fill = MainTransport)) +
      geom_bar(stat = "identity", width = 1, color = "white") +
      coord_polar("y", start = 0) +
      theme_void(base_size = 14) +
      theme(aspect.ratio = 1) +
      geom_text(aes(label = scales::percent(perc, accuracy = 1)),
                position = position_stack(vjust = 0.5), size = 5) +
      labs(title = paste("Transportation -", d$`Hospital Name`[1]),
           fill = "Legend")
  }
)

# Combine the individual plots (e.g., 3 across), collect legends, and add an overall title
combined <- patchwork::wrap_plots(plot_list, ncol = 3) +
  plot_layout(guides = "collect") +
  plot_annotation(title = "Transportation Method by Hospital")

# Display the combined plot
print(combined)

# Save the plot under the General Insights folder
ggsave("General Insights/Hospital_Transportation_Pie.png", plot = combined, width = 12, height = 4)

```
